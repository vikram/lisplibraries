<?xml version="1.0"?>
<documentation index-title="Closure HTML API reference" css="index.css" heading="Closure HTML">
  <package name="closure-html" id="closure-html">
    <sections>
      <section section="Parsing">    <aboutfun id="closure-html__fun__parse">parse</aboutfun>    </section>
      <section section="Serialization sinks">    <aboutfun id="closure-html__fun__make-octet-vector-sink">make-octet-vector-sink</aboutfun>    <aboutfun id="closure-html__fun__make-octet-stream-sink">make-octet-stream-sink</aboutfun>    <aboutfun id="closure-html__fun__make-rod-sink">make-rod-sink</aboutfun>    <aboutfun id="closure-html__fun__make-character-stream-sink">make-character-stream-sink</aboutfun>    <aboutfun id="closure-html__fun__make-string-sink">make-string-sink</aboutfun>    </section>
      <section section="Convenience serialization API">    <aboutmacro>with-html-output</aboutmacro>    <aboutmacro>with-element</aboutmacro>    <aboutmacro>with-output-sink</aboutmacro>    <aboutfun id="closure-html__fun__attribute">attribute</aboutfun>    <aboutfun id="closure-html__fun__text">text</aboutfun>    <aboutfun id="closure-html__fun__comment">comment</aboutfun>    </section>
      <section section="LHTML model">    <aboutfun id="closure-html__fun__make-lhtml-builder">make-lhtml-builder</aboutfun>    <aboutfun id="closure-html__fun__serialize-lhtml">serialize-lhtml</aboutfun>    </section>
      <section section="PT model">    <aboutfun id="closure-html__fun__make-pt-builder">make-pt-builder</aboutfun>    <aboutfun id="closure-html__fun__serialize-pt">serialize-pt</aboutfun>    <aboutfun id="sgml__fun__pt-name">pt-name</aboutfun>    <aboutfun id="sgml__fun__pt-children">pt-children</aboutfun>    <aboutfun id="sgml__fun__pt-parent">pt-parent</aboutfun>    <aboutfun id="sgml__fun__pt-attrs">pt-attrs</aboutfun>    </section>
    </sections>
    <documentation-string>This package exports functions for HTML parsing and serialization.<break/>
    In addition, two simple in-memory data structures are included: LHTML, a
    lisp-list model.  And PT, a simple structure instance model used by
    Closure internally.<break/>                    </documentation-string>
    <symbols>
      <function-definition id="closure-html__fun__make-lhtml-builder" name="make-lhtml-builder" package="closure-html">
        <lambda-list/>
        <see-also>
          <auto>
            <see id="closure-html__class__lhtml-builder">lhtml-builder</see>
          </auto>
          <other>
            <see id="closure-html__fun__parse">parse</see>
            <see id="closure-html__fun__serialize-lhtml">serialize-lhtml</see>
          </other>
        </see-also>
        <return>The <class id="closure-html__class__lhtml-builder">lhtml-builder</class>, a HAX handler.</return>
        <documentation-string>       <short>Create a HAX handler which builds LHTML list structures.</short><break/>
       Example:       <pre>
 (chtml:parse "&lt;p&gt;nada&lt;/p&gt;" (chtml:make-lhtml-builder))       </pre>       <code>
 =&gt; (:HTML NIL (:HEAD NIL) (:BODY NIL (:P NIL "nada")))       </code><break/>              </documentation-string>
      </function-definition>
      <function-definition id="sgml__fun__pt-name" name="pt-name" package="sgml">
        <lambda-list>
          <elt>instance</elt>
        </lambda-list>
        <arguments>
          <arg arg="instance">a <class id="sgml__class__pt">pt</class> node</arg>
        </arguments>
        <see-also>
          <auto>
            <see id="sgml__class__pt">pt</see>
          </auto>
        </see-also>
        <return>a keyword symbol</return>
        <documentation-string>              <short>Returns the element's name.</short><break/>
       HTML element names are symbols in the keyword package with uppercase       names.</documentation-string>
      </function-definition>
      <function-definition id="closure-html__fun__parse" name="parse" package="closure-html">
        <lambda-list>
          <elt>input</elt>
          <elt>handler</elt>
        </lambda-list>
        <arguments>
          <arg arg="input">a pathname, stream, string, or octet array</arg>
          <arg arg="handler">nil, or a HAX/SAX handler</arg>
        </arguments>
        <see-also>
          <auto>
            <see id="closure-html__fun__make-pt-builder">make-pt-builder</see>
            <see id="hax__class__abstract-handler">hax:abstract-handler</see>
            <see id="hax__fun__end-document">hax:end-document</see>
          </auto>
        </see-also>
        <return>The return value of this function is determined by the         <var>handler</var> argument; see below.</return>
        <documentation-string>                     <short>Parse the HTML document given as an argument, or referred to       using a pathname.</short><break/>       <var>input</var> can have one of the following types:       <itemize>       <item>pathname -- a Common Lisp pathname. Opens the file specified by         the pathname parses it as an HTML document.</item>       <item>stream -- a Common Lisp stream that has already been opened.</item>       <item>array -- an <code>(unsigned-byte 8)</code> array.  The array is parsed         directly, and interpreted according to the encoding it specifies.</item>       <item>string/rod -- a rod (or string on unicode-capable
         implementations). Parses an XML document from the input string that         has already undergone external-format decoding.</item>       </itemize><break/>       If <var>handler</var> is <code>nil</code>, the parser's internal representation
       of the document is returned.  The result is equivalent to that       returned using a PT builder as returned by <fun id="closure-html__fun__make-pt-builder">make-pt-builder</fun>, but
       avoids creating the same representation twice.<break/>       Alternatively, <var>handler</var> can be a HAX handler       (see <class id="hax__class__abstract-handler">hax:abstract-handler</class>) or a SAX handler (see the       <a a="http://common-lisp.net/project/cxml/sax.html#sax">SAX protocol in       cxml</a>). In this case, the document will be serialized to the specified       handler, and the result of <fun id="hax__fun__end-document">hax:end-document</fun> will be returned
       from this function. Note that the parser will currently always process       the entire document before sending the first HAX event.</documentation-string>
      </function-definition>
      <class-definition id="sgml__class__pt" name="pt" package="sgml">
        <cpl>
          <superclass status="EXTERNAL" name="structure-object" package="common-lisp"/>
          <superclass status="INTERNAL" name="slot-object" package="sb-pcl"/>
          <superclass status="EXTERNAL" name="t" package="common-lisp"/>
        </cpl>
        <subclasses/>
        <see-also>
          <other>
            <see id="sgml__fun__make-pt-builder">make-pt-builder</see>
            <see id="sgml__fun__serialize-pt">serialize-pt</see>
          </other>
          <slot>
            <see id="sgml__fun__pt-name">pt-name</see>
            <see id="sgml__fun__pt-children">pt-children</see>
            <see id="sgml__fun__pt-parent">pt-parent</see>
            <see id="sgml__fun__pt-attrs">pt-attrs</see>
          </slot>
        </see-also>
        <documentation-string><short>Represents an HTML element.</short><break/>
       PT represents each HTML element as a structure instance, named by
       a keyword symbol.  The children of a PT node are strings (rods)
       for text nodes, or other PT nodes for elements.<break/>                                          </documentation-string>
      </class-definition>
      <macro-definition id="closure-html__macro__with-element" name="with-element" package="closure-html">
        <lambda-list>
          <elt>name</elt>
          <elt>&amp;body</elt>
          <elt>body</elt>
        </lambda-list>
        <arguments>
          <arg arg="name">the element's name, a string/rod</arg>
          <arg arg="body">an implicit progn</arg>
        </arguments>
        <see-also>
          <auto>
            <see id="hax__fun__start-element">hax:start-element</see>
            <see id="hax__fun__end-element">hax:end-element</see>
            <see id="closure-html__fun__attribute">attribute</see>
            <see id="closure-html__macro__with-html-output">with-html-output</see>
          </auto>
        </see-also>
        <return>the value of <var>body</var></return>
        <documentation-string>                     <short>Generate <fun id="hax__fun__start-element">hax:start-element</fun> and <fun id="hax__fun__end-element">hax:end-element</fun>         events.</short><break/>       Execute <var>body</var> as an implicit progn.  Send a start-element event to
       the current sink (before the first child element begins, or the
       current element ends), including all attributes specified using       <fun id="closure-html__fun__attribute">attribute</fun> until that point.  Send an end-element event after       <var>body</var> is finished.<break/>       To be used in the extent of an <fun id="closure-html__macro__with-html-output">with-html-output</fun> invocation.</documentation-string>
      </macro-definition>
      <function-definition id="closure-html__fun__make-string-sink" name="make-string-sink" package="closure-html">
        <lambda-list>
          <elt>&amp;rest</elt>
          <elt>args</elt>
        </lambda-list>
        <see-also>
          <auto>
            <see id="hax__fun__end-document">hax:end-document</see>
          </auto>
          <other>
            <see id="closure-html__fun__make-character-stream-sink">make-character-stream-sink</see>
            <see id="closure-html__fun__make-octet-stream-sink">make-octet-stream-sink</see>
            <see id="closure-html__fun__make-octet-vector-sink">make-octet-vector-sink</see>
            <see id="closure-html__fun__make-rod-sink">make-rod-sink</see>
          </other>
        </see-also>
        <return>a HAX handler</return>
        <documentation-string>       <short>Returns a sink creating strings.</short><break/>
       This function creates a serialization sink.  Sinks are HAX handlers
       that write events in their normal HTML syntax, and return       the result from <fun id="hax__fun__end-document">hax:end-document</fun>, if applicable.<break/>
       This particular kind of sink creates an HTML document in a string.       The string is <em>not</em> encoded into an external-format.  When
       writing this string to a Lisp character stream at a later point, make
       sure that the stream's external format agrees with the encoding
       declared by the document, if any.<break/>       <b>Supported only on Lisps with Unicode support.</b>  On Lisps without       Unicode characters, try <em>make-string-sink/utf8</em> as an alternative
       that has different encoding behaviour, but still uses strings.  Or       use <em>make-rod-sink</em>, which creates arrays of code points.<break/>                            </documentation-string>
      </function-definition>
      <variable-definition id="closure-html__variable___html-dtd_" name="*html-dtd*" package="closure-html">
        <documentation-string>fixme: exported only for the benefit of Closure</documentation-string>
      </variable-definition>
      <function-definition id="closure-html__fun__comment" name="comment" package="closure-html">
        <lambda-list>
          <elt>data</elt>
        </lambda-list>
        <arguments>
          <arg arg="data">a string/rod</arg>
        </arguments>
        <see-also>
          <auto>
            <see id="closure-html__macro__with-html-output">with-html-output</see>
          </auto>
        </see-also>
        <return>the <var>data</var></return>
        <documentation-string>              <short>Write a comment node.</short><break/>       To be used in the extent of an <fun id="closure-html__macro__with-html-output">with-html-output</fun> invocation, this       function serializes a comment.</documentation-string>
      </function-definition>
      <function-definition id="sgml__fun__pt-children" name="pt-children" package="sgml">
        <lambda-list>
          <elt>instance</elt>
        </lambda-list>
        <arguments>
          <arg arg="instance">a <class id="sgml__class__pt">pt</class> node</arg>
        </arguments>
        <see-also>
          <auto>
            <see id="sgml__class__pt">pt</see>
          </auto>
          <other>
            <see id="sgml__fun__pt-parent">pt-parent</see>
          </other>
        </see-also>
        <return>a list</return>
        <documentation-string>              <short>Returns the element's children.</short><break/>
       The children of a PT node are strings (rods)
       for text nodes, or other PT nodes for elements.<break/>       </documentation-string>
      </function-definition>
      <function-definition id="closure-html__fun__text" name="text" package="closure-html">
        <lambda-list>
          <elt>data</elt>
        </lambda-list>
        <arguments>
          <arg arg="data">a string/rod</arg>
        </arguments>
        <see-also>
          <auto>
            <see id="closure-html__macro__with-html-output">with-html-output</see>
          </auto>
        </see-also>
        <return>the <var>data</var></return>
        <documentation-string>              <short>Write a text node.</short><break/>       To be used in the extent of an <fun id="closure-html__macro__with-html-output">with-html-output</fun> invocation, this       function serializes a text node.</documentation-string>
      </function-definition>
      <function-definition id="closure-html__fun__serialize-pt" name="serialize-pt" package="closure-html">
        <lambda-list>
          <elt>document</elt>
          <elt>handler</elt>
          <elt>&amp;key</elt>
          <elt>(name HTML)</elt>
          <elt>public-id</elt>
          <elt>system-id</elt>
        </lambda-list>
        <arguments>
          <arg arg="document">an <class id="sgml__class__pt">pt</class> instance</arg>
          <arg arg="handler">a HAX/SAX handler</arg>
          <arg arg="name">root element name, a rod/string</arg>
          <arg arg="public-id">nil or the Public ID, a rod/string</arg>
          <arg arg="system-id">nil or the System ID/URI, a rod/string</arg>
        </arguments>
        <see-also>
          <auto>
            <see id="sgml__class__pt">pt</see>
            <see id="hax__class__abstract-handler">hax:abstract-handler</see>
            <see id="hax__fun__end-document">hax:end-document</see>
          </auto>
          <other>
            <see id="closure-html__fun__parse">parse</see>
            <see id="closure-html__fun__make-pt-builder">make-pt-builder</see>
          </other>
        </see-also>
        <return>The return value of this function is determined by the         <var>handler</var> argument; see below.</return>
        <documentation-string>                                          <short>Serialize the PT node into HAX events, sent to the          specified HAX handler.</short><break/>       <var>handler</var> can be a HAX handler       (see <class id="hax__class__abstract-handler">hax:abstract-handler</class>) or a SAX handler (see the       <a a="http://common-lisp.net/project/cxml/sax.html#sax">SAX protocol in       cxml</a>).<break/>       The result of calling <fun id="hax__fun__end-document">hax:end-document</fun> on the handler will be
       returned from this function.<break/>       If <var>system-id</var> is specified, a doctype will be written       according to the arguments <var>name</var>, <var>public-id</var>, and       <var>system-id</var>.<break/>
       Use this function with a serialization sink to get a string or file
       with a serialized HTML document, or with a HAX/SAX builder to
       convert PT into a different representation, like DOM, LHTML, or
       STP.<break/>
       Example:       <pre>
 (let ((x (chtml:parse "&lt;p&gt;nada&lt;/p&gt;" (chtml:make-pt-builder)))))
   (chtml:serialize-pt x (chtml:make-string-sink))       </pre>       <code>
 =&gt; "&lt;HTML&gt;&lt;HEAD&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;P&gt;nada&lt;/P&gt;&lt;/BODY&gt;&lt;/HTML&gt;"       </code><break/>              </documentation-string>
      </function-definition>
      <class-definition id="closure-html__class__pt-builder" name="pt-builder" package="closure-html">
        <cpl>
          <superclass status="EXTERNAL" id="hax__class__abstract-handler" name="abstract-handler" package="hax"/>
          <superclass status="EXTERNAL" name="standard-object" package="common-lisp"/>
          <superclass status="INTERNAL" name="slot-object" package="sb-pcl"/>
          <superclass status="EXTERNAL" name="t" package="common-lisp"/>
        </cpl>
        <subclasses/>
        <see-also>
          <auto>
            <see id="sgml__class__pt">pt</see>
          </auto>
          <other>
            <see id="closure-html__fun__make-pt-builder">make-pt-builder</see>
            <see id="closure-html__fun__serialize-pt">serialize-pt</see>
          </other>
        </see-also>
        <documentation-string><short>A HAX handler which builds PT structures.</short><break/>
       PT represents each HTML element as a structure instance of type       <class id="sgml__class__pt">pt</class>.<break/>              </documentation-string>
      </class-definition>
      <class-definition id="closure-html__class__lhtml-builder" name="lhtml-builder" package="closure-html">
        <cpl>
          <superclass status="EXTERNAL" id="hax__class__abstract-handler" name="abstract-handler" package="hax"/>
          <superclass status="EXTERNAL" name="standard-object" package="common-lisp"/>
          <superclass status="INTERNAL" name="slot-object" package="sb-pcl"/>
          <superclass status="EXTERNAL" name="t" package="common-lisp"/>
        </cpl>
        <subclasses/>
        <see-also>
          <other>
            <see id="closure-html__fun__make-lhtml-builder">make-lhtml-builder</see>
            <see id="closure-html__fun__serialize-lhtml">serialize-lhtml</see>
          </other>
        </see-also>
        <documentation-string><short>A HAX handler which builds LHTML list structures.</short><break/>
       LHTML represents each HTML element as a list of the form<break/>  <code>(</code><em>name</em><code> (</code><em>attributes...</em><code>) </code><em>children...</em><code>)</code><break/>
       and each attribute as a list of the form<break/>  <code>(</code><em>name value</em><code>)</code><break/>
       Element and attribute names are symbols in the keyword package
       with uppercase names.  Attribute values are rods or strings.<break/>              </documentation-string>
      </class-definition>
      <macro-definition id="closure-html__macro__with-html-output" name="with-html-output" package="closure-html">
        <lambda-list>
          <elt>(sink &amp;key (name HTML) public-id system-id)</elt>
          <elt>&amp;body</elt>
          <elt>body</elt>
        </lambda-list>
        <arguments>
          <arg arg="sink">a HAX/SAX handler</arg>
          <arg arg="name">root element name, a rod/string</arg>
          <arg arg="public-id">nil or the Public ID, a rod/string</arg>
          <arg arg="system-id">nil or the System ID/URI, a rod/string</arg>
          <arg arg="body">an implicit progn</arg>
        </arguments>
        <see-also>
          <auto>
            <see id="hax__fun__start-document">hax:start-document</see>
            <see id="hax__fun__end-document">hax:end-document</see>
          </auto>
          <other>
            <see id="closure-html__macro__with-output-sink">with-output-sink</see>
            <see id="closure-html__macro__with-element">with-element</see>
            <see id="closure-html__fun__attribute">attribute</see>
            <see id="closure-html__fun__text">text</see>
            <see id="closure-html__fun__comment">comment</see>
          </other>
        </see-also>
        <return>the value of <var>body</var></return>
        <documentation-string>                                          <short>Generate <fun id="hax__fun__start-document">hax:start-document</fun> and <fun id="hax__fun__end-document">hax:end-document</fun>         events.</short><break/>
       Send a start-document event to the current sink, then execute       <var>body</var> as an implicit progn.  Afterwards, send an end-element
       event.<break/>                                   </documentation-string>
      </macro-definition>
      <function-definition id="closure-html__fun__make-octet-stream-sink" name="make-octet-stream-sink" package="closure-html">
        <lambda-list>
          <elt>stream</elt>
          <elt>&amp;rest</elt>
          <elt>initargs</elt>
        </lambda-list>
        <see-also>
          <other>
            <see id="closure-html__fun__make-character-stream-sink">make-character-stream-sink</see>
            <see id="closure-html__fun__make-octet-vector-sink">make-octet-vector-sink</see>
            <see id="closure-html__fun__make-rod-sink">make-rod-sink</see>
            <see id="closure-html__fun__make-string-sink">make-string-sink</see>
          </other>
        </see-also>
        <return>a HAX handler</return>
        <documentation-string>       <short>Returns a sink writing to an octet stream.</short><break/>
       This function creates a serialization sink.  Sinks are HAX handlers
       that write events in their normal HTML syntax.<break/>
       This particular kind of sink writen the HTML document to a stream       of element-type <code>(unsigned-byte 8)</code>.<break/>                            </documentation-string>
      </function-definition>
      <function-definition id="closure-html__fun__make-rod-sink" name="make-rod-sink" package="closure-html">
        <lambda-list>
          <elt>&amp;rest</elt>
          <elt>initargs</elt>
        </lambda-list>
        <see-also>
          <auto>
            <see id="hax__fun__end-document">hax:end-document</see>
          </auto>
          <other>
            <see id="closure-html__fun__make-character-stream-sink">make-character-stream-sink</see>
            <see id="closure-html__fun__make-octet-stream-sink">make-octet-stream-sink</see>
            <see id="closure-html__fun__make-octet-vector-sink">make-octet-vector-sink</see>
            <see id="closure-html__fun__make-string-sink">make-string-sink</see>
          </other>
        </see-also>
        <return>a HAX handler</return>
        <documentation-string>       <short>Returns a sink creating rods.</short><break/>
       This function creates a serialization sink.  Sinks are HAX handlers
       that write events in their normal HTML syntax, and return       the result from <fun id="hax__fun__end-document">hax:end-document</fun>, if applicable.<break/>
       This particular kind of sink creates an HTML document in a rod.<break/>       On Lisps with Unicode support, <code>make-string-sink</code> is an alias for
       this function.<break/>                            </documentation-string>
      </function-definition>
      <function-definition id="closure-html__fun__make-octet-vector-sink" name="make-octet-vector-sink" package="closure-html">
        <lambda-list>
          <elt>&amp;rest</elt>
          <elt>initargs</elt>
        </lambda-list>
        <see-also>
          <auto>
            <see id="hax__fun__end-document">hax:end-document</see>
          </auto>
          <other>
            <see id="closure-html__fun__make-character-stream-sink">make-character-stream-sink</see>
            <see id="closure-html__fun__make-octet-stream-sink">make-octet-stream-sink</see>
            <see id="closure-html__fun__make-rod-sink">make-rod-sink</see>
            <see id="closure-html__fun__make-string-sink">make-string-sink</see>
          </other>
        </see-also>
        <return>a HAX handler</return>
        <documentation-string>       <short>Returns a sink creating octet vectors.</short><break/>
       This function creates a serialization sink.  Sinks are HAX handlers
       that write events in their normal HTML syntax, and return       the result from <fun id="hax__fun__end-document">hax:end-document</fun>, if applicable.<break/>
       This particular kind of sink creates an HTML document in an array       of <code>(unsigned-byte 8)</code>.<break/>                            </documentation-string>
      </function-definition>
      <function-definition id="closure-html__fun__make-character-stream-sink" name="make-character-stream-sink" package="closure-html">
        <lambda-list>
          <elt>stream</elt>
          <elt>&amp;rest</elt>
          <elt>initargs</elt>
        </lambda-list>
        <see-also>
          <other>
            <see id="closure-html__fun__make-octet-stream-sink">make-octet-stream-sink</see>
            <see id="closure-html__fun__make-octet-vector-sink">make-octet-vector-sink</see>
            <see id="closure-html__fun__make-rod-sink">make-rod-sink</see>
            <see id="closure-html__fun__make-string-sink">make-string-sink</see>
          </other>
        </see-also>
        <return>a HAX handler</return>
        <documentation-string>       <short>Returns a sink writing to a character stream.</short><break/>
       This function creates a serialization sink.  Sinks are HAX handlers
       that write events in their normal HTML syntax.<break/>
       This particular kind of sink writen the HTML document to a stream       of element-type <code>character</code>. The characters written are <em>not</em>
       encoded into an external-format. Make sure that the stream's external
       format agrees with the encoding declared by the document, if any.<break/>       <b>Supported only on Lisps with Unicode support.</b>  On Lisps without       Unicode characters, try <em>make-character-stream-sink/utf8</em> as
       an alternative that has different encoding behaviour, but still uses
       character streams.<break/>                            </documentation-string>
      </function-definition>
      <function-definition id="closure-html__fun__attribute" name="attribute" package="closure-html">
        <lambda-list>
          <elt>name</elt>
          <elt>value</elt>
        </lambda-list>
        <arguments>
          <arg arg="name">a string/rod</arg>
          <arg arg="value">a string/rod or other object</arg>
        </arguments>
        <see-also>
          <auto>
            <see id="closure-html__macro__with-element">with-element</see>
          </auto>
        </see-also>
        <return>the <var>value</var></return>
        <documentation-string>                     <short>Add an attribute to the current element.</short><break/>       To be used in the extent of an <fun id="closure-html__macro__with-element">with-element</fun> invocation, this       function adds an attribute to the element being serialized.</documentation-string>
      </function-definition>
      <function-definition id="closure-html__fun__serialize-lhtml" name="serialize-lhtml" package="closure-html">
        <lambda-list>
          <elt>document</elt>
          <elt>handler</elt>
          <elt>&amp;key</elt>
          <elt>(name HTML)</elt>
          <elt>public-id</elt>
          <elt>system-id</elt>
        </lambda-list>
        <arguments>
          <arg arg="document">an LHTML list</arg>
          <arg arg="handler">a HAX/SAX handler</arg>
          <arg arg="name">root element name, a rod/string</arg>
          <arg arg="public-id">nil or the Public ID, a rod/string</arg>
          <arg arg="system-id">nil or the System ID/URI, a rod/string</arg>
        </arguments>
        <see-also>
          <auto>
            <see id="hax__class__abstract-handler">hax:abstract-handler</see>
            <see id="hax__fun__end-document">hax:end-document</see>
          </auto>
          <other>
            <see id="closure-html__fun__parse">parse</see>
            <see id="closure-html__fun__make-lhtml-builder">make-lhtml-builder</see>
          </other>
        </see-also>
        <return>The return value of this function is determined by the         <var>handler</var> argument; see below.</return>
        <documentation-string>                                          <short>Serialize the LHTML document into HAX events, sent to the          specified HAX handler.</short><break/>       <var>handler</var> can be a HAX handler       (see <class id="hax__class__abstract-handler">hax:abstract-handler</class>) or a SAX handler (see the       <a a="http://common-lisp.net/project/cxml/sax.html#sax">SAX protocol in       cxml</a>).<break/>       The result of calling <fun id="hax__fun__end-document">hax:end-document</fun> on the handler will be
       returned from this function.<break/>       If <var>system-id</var> is specified, a doctype will be written       according to the arguments <var>name</var>, <var>public-id</var>, and       <var>system-id</var>.<break/>
       Use this function with a serialization sink to get a string or file
       with a serialized HTML document, or with a HAX/SAX builder to
       convert LHTML into a different representation, like DOM, PT, or
       STP.<break/>
       Example:       <pre>
 (let ((x '(:HTML NIL (:HEAD NIL) (:BODY NIL (:P NIL "nada"))))))
   (chtml:serialize-lhtml x (chtml:make-string-sink))       </pre>       <code>
 =&gt; "&lt;HTML&gt;&lt;HEAD&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;P&gt;nada&lt;/P&gt;&lt;/BODY&gt;&lt;/HTML&gt;"       </code><break/>              </documentation-string>
      </function-definition>
      <function-definition id="closure-html__fun__make-pt-builder" name="make-pt-builder" package="closure-html">
        <lambda-list/>
        <see-also>
          <auto>
            <see id="closure-html__class__pt-builder">pt-builder</see>
            <see id="sgml__class__pt">pt</see>
          </auto>
          <other>
            <see id="closure-html__fun__parse">parse</see>
            <see id="closure-html__fun__serialize-pt">serialize-pt</see>
          </other>
        </see-also>
        <return>The <class id="closure-html__class__pt-builder">pt-builder</class>, a HAX handler.</return>
        <documentation-string>       <short>Create a HAX handler which builds <class id="sgml__class__pt">pt</class> structures.</short><break/>
       Example:       <pre>
 (chtml:parse "&lt;p&gt;nada&lt;/p&gt;" (chtml:make-pt-builder))       </pre>       <code>
 =&gt; #&lt;SGML:PT HTML ..&gt;       </code><break/>              </documentation-string>
      </function-definition>
      <function-definition id="sgml__fun__pt-parent" name="pt-parent" package="sgml">
        <lambda-list>
          <elt>instance</elt>
        </lambda-list>
        <arguments>
          <arg arg="instance">a <class id="sgml__class__pt">pt</class> node</arg>
        </arguments>
        <see-also>
          <auto>
            <see id="sgml__class__pt">pt</see>
            <see id="sgml__class__pt">pt</see>
          </auto>
          <other>
            <see id="sgml__fun__pt-children">pt-children</see>
          </other>
        </see-also>
        <return>nil, or a <class id="sgml__class__pt">pt</class> node</return>
        <documentation-string>              <short>Returns the element's parent node.</short><break/>
       This slot should refer to the node's parent, if it is included
       in the list of that node's children.<break/>       </documentation-string>
      </function-definition>
      <function-definition id="sgml__fun__pt-attrs" name="pt-attrs" package="sgml">
        <lambda-list>
          <elt>instance</elt>
        </lambda-list>
        <arguments>
          <arg arg="instance">a <class id="sgml__class__pt">pt</class> node</arg>
        </arguments>
        <see-also>
          <auto>
            <see id="sgml__class__pt">pt</see>
          </auto>
        </see-also>
        <return>a plist</return>
        <documentation-string>              <short>Returns the element's attributes as a plist.</short><break/>
       This plist maps attribute names to their values. <break/>
       Attribute names are symbols in the keyword package with uppercase       names.  Attribute values are strings/rods.</documentation-string>
      </function-definition>
      <macro-definition id="closure-html__macro__with-output-sink" name="with-output-sink" package="closure-html">
        <lambda-list>
          <elt>(var)</elt>
          <elt>&amp;body</elt>
          <elt>body</elt>
        </lambda-list>
        <arguments>
          <arg arg="var">the variable name, a symbol</arg>
          <arg arg="body">an implicit progn</arg>
        </arguments>
        <see-also>
          <auto>
            <see id="closure-html__macro__with-html-output">with-html-output</see>
          </auto>
        </see-also>
        <return>the value of <var>body</var></return>
        <documentation-string>                     <short>Bind a variable to the current serialization sink.</short><break/>       Execute <var>body</var> as an implicit progn with <var>var</var> bound to a       serialization sink that <var>body</var> can safely call HAX functions on.<break/>       To be used in the extent of an <fun id="closure-html__macro__with-html-output">with-html-output</fun> invocation.</documentation-string>
      </macro-definition>
    </symbols>
  </package>
  <package name="hax" id="hax">
    <sections>
      <section section="HAX handlers">       <aboutclass>abstract-handler</aboutclass>       <aboutclass>default-handler</aboutclass>       </section>
      <section section="The attribute protocol">       <aboutclass>standard-attribute</aboutclass>       <aboutfun id="hax__fun__make-attribute">make-attribute</aboutfun>       <aboutfun id="hax__fun__attribute-name">attribute-name</aboutfun>       <aboutfun id="hax__fun__attribute-value">attribute-value</aboutfun>       <aboutfun id="hax__fun__attribute-specified-p">attribute-specified-p</aboutfun>       </section>
      <section section="HAX events">       <aboutfun id="hax__fun__start-document">start-document</aboutfun>       <aboutfun id="hax__fun__start-element">start-element</aboutfun>       <aboutfun id="hax__fun__end-element">end-element</aboutfun>       <aboutfun id="hax__fun__characters">characters</aboutfun>       <aboutfun id="hax__fun__comment">comment</aboutfun>       <aboutfun id="hax__fun__end-document">end-document</aboutfun>       </section>
    </sections>
    <documentation-string>An event protocol for HTML serialization, this package is similar
       to the SAX protocol defined by cxml for XML serialization.<break/>
       (Technically, this package should have been spelled SAH, but HAX
       sounds better.)<break/>
       Note that Closure HTML is not a streaming parser yet.  Documents
       are always parsed in full before the first HAX event is emitted.
       In spite of this restriction, the HAX API is useful for HTML
       serialization and transformation purposes, and for integration
       with SAX.<break/>                     </documentation-string>
    <symbols>
      <class-definition id="hax__class__default-handler" name="default-handler" package="hax">
        <cpl>
          <superclass status="EXTERNAL" id="hax__class__abstract-handler" name="abstract-handler" package="hax"/>
          <superclass status="EXTERNAL" name="standard-object" package="common-lisp"/>
          <superclass status="INTERNAL" name="slot-object" package="sb-pcl"/>
          <superclass status="EXTERNAL" name="t" package="common-lisp"/>
        </cpl>
        <subclasses/>
        <see-also>
          <other>
            <see id="closure-html__fun__parse">chtml:parse</see>
            <see id="closure-html__fun__serialize-lhtml">chtml:serialize-lhtml</see>
            <see id="closure-html__fun__serialize-pt">chtml:serialize-pt</see>
            <see id="hax__fun__start-document">start-document</see>
            <see id="hax__fun__end-document">end-document</see>
            <see id="hax__fun__start-element">start-element</see>
            <see id="hax__fun__end-element">end-element</see>
            <see id="hax__fun__characters">characters</see>
            <see id="hax__fun__comment">comment</see>
          </other>
        </see-also>
        <documentation-string><short>A no-op HAX handler.</short><break/>
       This class defines methods for all HAX events that do nothing.
       It is useful as a superclass when implementing a HAX handler that
       is interested in only some events and not others.<break/>                                                               </documentation-string>
      </class-definition>
      <function-definition id="hax__fun__make-attribute" name="make-attribute" package="hax">
        <lambda-list>
          <elt>name</elt>
          <elt>value</elt>
          <elt>&amp;optional</elt>
          <elt>(specified-p t)</elt>
        </lambda-list>
        <arguments>
          <arg arg="name">a string/rod</arg>
          <arg arg="value">a string/rod</arg>
          <arg arg="specified-p">a boolean, default is <code>t</code></arg>
        </arguments>
        <see-also>
          <auto>
            <see id="hax__class__standard-attribute">standard-attribute</see>
            <see id="hax__fun__start-element">hax:start-element</see>
          </auto>
          <other>
            <see id="hax__fun__attribute-name">attribute-name</see>
            <see id="hax__fun__attribute-value">attribute-value</see>
            <see id="hax__fun__attribute-specified-p">attribute-specified-p</see>
          </other>
        </see-also>
        <return>an instance of <class id="hax__class__standard-attribute">standard-attribute</class>.</return>
        <documentation-string>                            <short>Creates a HAX attribute.</short><break/>
       Creates an instance that can be used with the generic functions
       for HAX attributes.  The result can be passed to       <fun id="hax__fun__start-element">hax:start-element</fun> in the list of attributes.<break/>                     </documentation-string>
      </function-definition>
      <function-definition id="hax__fun__end-element" name="end-element" package="hax">
        <lambda-list>
          <elt>handler</elt>
          <elt>name</elt>
        </lambda-list>
        <arguments>
          <arg arg="handler">a HAX/SAX handler         (see <class id="hax__class__abstract-handler">abstract-handler</class> for details)</arg>
          <arg arg="name">root element name, a rod/string</arg>
        </arguments>
        <see-also>
          <auto>
            <see id="hax__class__abstract-handler">abstract-handler</see>
          </auto>
          <other>
            <see id="hax__fun__start-document">start-document</see>
            <see id="hax__fun__start-element">start-element</see>
            <see id="hax__fun__characters">characters</see>
            <see id="hax__fun__comment">comment</see>
            <see id="hax__fun__end-document">end-document</see>
          </other>
        </see-also>
        <return>unspecified</return>
        <documentation-string>                     <short>Signals the end of an HTML element.</short><break/>
       This event corresponds to the closing tag of an element.<break/>                                   </documentation-string>
      </function-definition>
      <function-definition id="hax__fun__start-element" name="start-element" package="hax">
        <lambda-list>
          <elt>handler</elt>
          <elt>name</elt>
          <elt>attributes</elt>
        </lambda-list>
        <arguments>
          <arg arg="handler">a HAX/SAX handler         (see <class id="hax__class__abstract-handler">abstract-handler</class> for details)</arg>
          <arg arg="name">root element name, a rod/string</arg>
          <arg arg="attributes">a list of attributes</arg>
        </arguments>
        <see-also>
          <auto>
            <see id="hax__class__abstract-handler">abstract-handler</see>
            <see id="hax__class__standard-attribute">standard-attribute</see>
          </auto>
          <other>
            <see id="hax__fun__find-attribute">find-attribute</see>
            <see id="hax__fun__start-document">start-document</see>
            <see id="hax__fun__end-element">end-element</see>
            <see id="hax__fun__characters">characters</see>
            <see id="hax__fun__comment">comment</see>
            <see id="hax__fun__end-document">end-document</see>
          </other>
        </see-also>
        <return>unspecified</return>
        <documentation-string>                            <short>Signals the beginning of an HTML element.</short><break/>
       This event corresponds to the opening tag of an element.<break/>
       Elements of the attribute list can have any class, but must implement       the generic functions for attributes.  See <class id="hax__class__standard-attribute">standard-attribute</class>
       for the built-in attribute implementation.<break/>                                          </documentation-string>
      </function-definition>
      <function-definition id="hax__fun__attribute-value" name="attribute-value" package="hax">
        <lambda-list>
          <elt>attribute</elt>
        </lambda-list>
        <arguments>
          <arg arg="instance">any class implementing this function</arg>
        </arguments>
        <see-also>
          <auto>
            <see id="hax__fun__start-element">hax:start-element</see>
          </auto>
          <other>
            <see id="hax__fun__attribute-name">attribute-name</see>
            <see id="hax__fun__attribute-specified-p">attribute-specified-p</see>
          </other>
        </see-also>
        <return>a string/rod</return>
        <documentation-string>              <short>Return an attribute's value.</short><break/>
       Instances of this classes implementing this function can be passed to       <fun id="hax__fun__start-element">hax:start-element</fun> in the list of attributes.<break/>              </documentation-string>
      </function-definition>
      <function-definition id="hax__fun__attribute-specified-p" name="attribute-specified-p" package="hax">
        <lambda-list>
          <elt>attribute</elt>
        </lambda-list>
        <arguments>
          <arg arg="instance">any class implementing this function</arg>
        </arguments>
        <see-also>
          <auto>
            <see id="hax__fun__start-element">hax:start-element</see>
          </auto>
          <other>
            <see id="hax__fun__attribute-name">attribute-name</see>
            <see id="hax__fun__attribute-value">attribute-value</see>
          </other>
        </see-also>
        <return>a string/rod</return>
        <documentation-string>              <short>Return whether the attribute was contained the parsed document.</short><break/>       Attributes return <code>nil</code> here if they resulted from a default
       value declaration in a DTD.<break/>
       Instances of this classes implementing this function can be passed to       <fun id="hax__fun__start-element">hax:start-element</fun> in the list of attributes.<break/>              </documentation-string>
      </function-definition>
      <class-definition id="hax__class__standard-attribute" name="standard-attribute" package="hax">
        <cpl>
          <superclass status="EXTERNAL" name="standard-object" package="common-lisp"/>
          <superclass status="INTERNAL" name="slot-object" package="sb-pcl"/>
          <superclass status="EXTERNAL" name="t" package="common-lisp"/>
        </cpl>
        <subclasses/>
        <see-also>
          <auto>
            <see id="hax__fun__start-element">hax:start-element</see>
          </auto>
          <slot>
            <see id="hax__fun__attribute-name">attribute-name</see>
            <see id="hax__fun__attribute-value">attribute-value</see>
            <see id="hax__fun__attribute-specified-p">attribute-specified-p</see>
          </slot>
          <constructor>
            <see id="common-lisp__fun__make-instance">make-instance</see>
          </constructor>
        </see-also>
        <documentation-string><short>An implementation of the HAX attribute protocol.</short><break/>
       A standard class implementing the generic functions for HAX
       attributes.  Instances of this class can be passed to       <fun id="hax__fun__start-element">hax:start-element</fun> in the list of attributes.<break/>                            </documentation-string>
      </class-definition>
      <function-definition id="hax__fun__characters" name="characters" package="hax">
        <lambda-list>
          <elt>handler</elt>
          <elt>data</elt>
        </lambda-list>
        <arguments>
          <arg arg="handler">a HAX/SAX handler         (see <class id="hax__class__abstract-handler">abstract-handler</class> for details)</arg>
          <arg arg="data">rod/string</arg>
        </arguments>
        <see-also>
          <auto>
            <see id="hax__class__abstract-handler">abstract-handler</see>
          </auto>
          <other>
            <see id="hax__fun__start-document">start-document</see>
            <see id="hax__fun__start-element">start-element</see>
            <see id="hax__fun__end-element">end-element</see>
            <see id="hax__fun__comment">comment</see>
            <see id="hax__fun__end-document">end-document</see>
          </other>
        </see-also>
        <return>unspecified</return>
        <documentation-string>                     <short>Signals character data.</short><break/>
       This event represents character data in a document.<break/>                                   </documentation-string>
      </function-definition>
      <class-definition id="hax__class__abstract-handler" name="abstract-handler" package="hax">
        <cpl>
          <superclass status="EXTERNAL" name="standard-object" package="common-lisp"/>
          <superclass status="INTERNAL" name="slot-object" package="sb-pcl"/>
          <superclass status="EXTERNAL" name="t" package="common-lisp"/>
        </cpl>
        <subclasses>
          <subclass status="EXTERNAL" id="closure-html__class__lhtml-builder" name="lhtml-builder" package="closure-html"/>
          <subclass status="EXTERNAL" id="closure-html__class__pt-builder" name="pt-builder" package="closure-html"/>
          <subclass status="EXTERNAL" id="hax__class__default-handler" name="default-handler" package="hax"/>
        </subclasses>
        <see-also>
          <other>
            <see id="closure-html__fun__parse">chtml:parse</see>
            <see id="closure-html__fun__serialize-lhtml">chtml:serialize-lhtml</see>
            <see id="closure-html__fun__serialize-pt">chtml:serialize-pt</see>
            <see id="hax__fun__start-document">start-document</see>
            <see id="hax__fun__end-document">end-document</see>
            <see id="hax__fun__start-element">start-element</see>
            <see id="hax__fun__end-element">end-element</see>
            <see id="hax__fun__characters">characters</see>
            <see id="hax__fun__comment">comment</see>
          </other>
        </see-also>
        <documentation-string><short>The superclass of all HAX handlers.</short><break/>
       Direct subclasses have to implement all event methods, since
       no default methods are defined on this class.<break/>
       Note that it is permissible to use handlers that are not
       instances of this class in some circumstances.<break/>
       In particular,       <code>nil</code> is a valid HAX handler and ignores all events.<break/>
       In addition,       <a a="http://common-lisp.net/project/cxml/sax.html#sax">SAX handlers</a>
       are valid HAX handlers (and vice versa), even though
       hax:abstract-handler and sax:abstract-handler do not
       share a specific superclass.  HAX events sent to SAX handlers are
       automatically re-signalled as XHTML SAX events, and SAX events sent
       to HAX handlers are re-signalled as namespace-less HAX events.<break/>
       However, user code should define subclasses of the documented
       superclasses to enable the HAX/SAX bridging described above.<break/>                                                               </documentation-string>
      </class-definition>
      <function-definition id="hax__fun__end-document" name="end-document" package="hax">
        <lambda-list>
          <elt>handler</elt>
        </lambda-list>
        <arguments>
          <arg arg="handler">a HAX/SAX handler         (see <class id="hax__class__abstract-handler">abstract-handler</class> for details)</arg>
        </arguments>
        <see-also>
          <auto>
            <see id="hax__class__abstract-handler">abstract-handler</see>
          </auto>
          <other>
            <see id="hax__fun__start-document">start-document</see>
            <see id="hax__fun__start-element">start-element</see>
            <see id="hax__fun__end-element">end-element</see>
            <see id="hax__fun__characters">characters</see>
            <see id="hax__fun__comment">comment</see>
          </other>
        </see-also>
        <return>The return value of this function depends on the handler class.</return>
        <documentation-string>              <short>Signals the end of an HTML document.</short><break/>
       This is the last event sent to any handler, and signals the end of
       serialization.<break/>
       The return value of this function is usually returned to user code
       by higher-level serialization functions and can be considered the
       result of serialization and "return value" of the handler.<break/>                                   </documentation-string>
      </function-definition>
      <function-definition id="hax__fun__find-attribute" name="find-attribute" package="hax">
        <lambda-list>
          <elt>name</elt>
          <elt>attrs</elt>
        </lambda-list>
        <arguments>
          <arg arg="name">a string/rod</arg>
          <arg arg="attrs">a list of attributes</arg>
        </arguments>
        <see-also>
          <other>
            <see id="hax__fun__attribute-name">attribute-name</see>
          </other>
        </see-also>
        <return>an attribute, or nil</return>
        <documentation-string>                     <short>Searches for an attribute by name.</short><break/>       Returns the first attribute in <var>attrs</var> with the specified name,       or <code>nil</code> if no such attribute was found.<break/>       </documentation-string>
      </function-definition>
      <function-definition id="hax__fun__start-document" name="start-document" package="hax">
        <lambda-list>
          <elt>handler</elt>
          <elt>name</elt>
          <elt>public-id</elt>
          <elt>system-id</elt>
        </lambda-list>
        <arguments>
          <arg arg="handler">a HAX/SAX handler         (see <class id="hax__class__abstract-handler">abstract-handler</class> for details)</arg>
          <arg arg="name">root element name, a rod/string</arg>
          <arg arg="public-id">nil or the Public ID, a rod/string</arg>
          <arg arg="system-id">nil or the System ID/URI, a rod/string</arg>
        </arguments>
        <see-also>
          <auto>
            <see id="hax__class__abstract-handler">abstract-handler</see>
          </auto>
          <other>
            <see id="hax__fun__start-element">start-element</see>
            <see id="hax__fun__end-element">end-element</see>
            <see id="hax__fun__characters">characters</see>
            <see id="hax__fun__comment">comment</see>
            <see id="hax__fun__end-document">end-document</see>
          </other>
        </see-also>
        <return>unspecified</return>
        <documentation-string>                                   <short>Signals the beginning of an HTML document.</short><break/>
       This is the first event sent to any handler.<break/>       If <var>system-id</var> is non-nil, the document includes a doctype
       declaration.<break/>                                   </documentation-string>
      </function-definition>
      <function-definition id="hax__fun__comment" name="comment" package="hax">
        <lambda-list>
          <elt>handler</elt>
          <elt>data</elt>
        </lambda-list>
        <arguments>
          <arg arg="handler">a HAX/SAX handler         (see <class id="hax__class__abstract-handler">abstract-handler</class> for details)</arg>
          <arg arg="data">rod/string</arg>
        </arguments>
        <see-also>
          <auto>
            <see id="hax__class__abstract-handler">abstract-handler</see>
          </auto>
          <other>
            <see id="hax__fun__start-document">start-document</see>
            <see id="hax__fun__start-element">start-element</see>
            <see id="hax__fun__end-element">end-element</see>
            <see id="hax__fun__characters">characters</see>
            <see id="hax__fun__end-document">end-document</see>
          </other>
        </see-also>
        <return>unspecified</return>
        <documentation-string>                     <short>Signals a comment.</short><break/>
       This event represents a comment.<break/>                                   </documentation-string>
      </function-definition>
      <function-definition id="hax__fun__attribute-name" name="attribute-name" package="hax">
        <lambda-list>
          <elt>attribute</elt>
        </lambda-list>
        <arguments>
          <arg arg="instance">any class implementing this function</arg>
        </arguments>
        <see-also>
          <auto>
            <see id="hax__fun__start-element">hax:start-element</see>
          </auto>
          <other>
            <see id="hax__fun__attribute-value">attribute-value</see>
            <see id="hax__fun__attribute-specified-p">attribute-specified-p</see>
          </other>
        </see-also>
        <return>a string/rod</return>
        <documentation-string>              <short>Return an attribute's name.</short><break/>
       Instances of this classes implementing this function can be passed to       <fun id="hax__fun__start-element">hax:start-element</fun> in the list of attributes.<break/>              </documentation-string>
      </function-definition>
    </symbols>
  </package>
</documentation>
