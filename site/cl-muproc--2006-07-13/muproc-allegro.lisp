;;;; -*- Mode: Lisp; indent-tabs-mode: nil -*-
;;;
;;; Copyright (c) 2006, Luis Oliveira. All rights reserved.
;;;
;;; Redistribution and use in source and binary forms, with or without
;;; modification, are permitted provided that the following conditions
;;; are met:
;;;
;;;   * Redistributions of source code must retain the above copyright
;;;     notice, this list of conditions and the following disclaimer.
;;;
;;;   * Redistributions in binary form must reproduce the above
;;;     copyright notice, this list of conditions and the following
;;;     disclaimer in the documentation and/or other materials
;;;     provided with the distribution.
;;;
;;; THIS SOFTWARE IS PROVIDED BY THE AUTHOR 'AS IS' AND ANY EXPRESSED
;;; OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
;;; WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;;; ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
;;; DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
;;; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
;;; GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;;; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
;;; WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
;;; NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
;;; SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

;;; This port to Allegro CL is heavily based on Rudi Schlatte's
;;; OpenMCL port.

(in-package #:cl-muproc.compat)

(eval-when (:compile-toplevel :load-toplevel :execute)
  (require :process))

(declaim (inline %make-lock% %make-queue% %enqueue% %dequeue% %queue-empty-p%
                 %all-processes% %current-process% %process-alive-p%
                 %process-interrupt% %process-p% %process-priority%
                 %process-run-function% %make-timer% %schedule-timer-relative%
                 %unschedule-timer%))

;;; DEBUGGING

(defmacro %with-debugging-stack% (&body body)
  "This macro sets up a debuggable stack, enabling stack dumps in
error and signal handlers -- default no-op implementation."
  `(progn ,@body))

;;; SCHEDULING

(defun %make-lock% (&key name)
  (mp:make-process-lock :name name))

(defmacro %with-exclusive-access% (&body body)
  `(mp:with-process-lock (*giant-lock* :norecursive t)
     ,@body))

(defmacro %with-lock% ((lock) &body body)
  `(mp:with-process-lock (,lock :norecursive t)
     ,@body))

;;; SPECIALS

(defvar *giant-lock* (%make-lock%))

;;; QUEUES

(defun %make-queue% ()
  (make-instance 'mp:queue))

(defun %enqueue% (queue packet)
  (mp:enqueue queue packet))

(defun %dequeue% (queue)
  (mp:dequeue queue :wait t))

(defun %queue-empty-p% (queue)
  (mp:queue-empty-p queue))

;;; PROCESSES

(defclass muproc-process (mp:process)
  ((plist :initform nil :accessor %process-plist%)))

(defun %all-processes% ()
  sys:*all-processes*)

(defun %current-process% ()
  "Returns a reference to the currently running muproc.  The
reference is identical to that of the underlying lisp process."
  sys:*current-process*)

(defun %process-alive-p% (muproc)
  (mp:process-alive-p muproc))

(defun %process-interrupt% (muproc fn &rest args)
  (apply #'mp:process-interrupt muproc fn args))

;; HACK: we don't tell muproc about processes generated by other means
;; (cf. `muproc-p' in muproc.lisp)
(defun %process-p% (obj)
  (typep obj 'muproc-process))

(defun %process-priority% (muproc)
  (mp:process-priority muproc))

(defun %process-run-function% (name fn &rest args)
  (let ((process (mp:make-process :name name :class 'muproc-process)))
    (apply #'mp:process-preset process fn args)
    (mp:process-enable process)
    process))

;;; TIMERS

(defclass timer (mp:process)
  ((function :initarg :timer-function :reader timer-function)
   (args     :initarg :timer-args     :reader timer-function-args)))

(defun %make-timer% (fn muproc)
  (mp:make-process :class 'timer
                   :timer-function fn
                   :timer-args (list muproc)))

(defun do-after (timer time)
  (mp:process-preset
   timer
   (lambda ()
     (mp:process-sleep time)
     (apply (timer-function timer) (timer-function-args timer))))
  (mp:process-enable timer))

(defun do-every (timer time interval)
  (mp:process-preset
   timer
   (lambda ()
     (mp:process-sleep time)
     (apply (timer-function timer) (timer-function-args timer))
     (loop (mp:process-sleep interval)
           (apply (timer-function timer) (timer-function-args timer)))))
  (mp:process-enable timer))

(defun %schedule-timer-relative% (timer relative-expiry-time
                                  &optional repeat-period)
  (if repeat-period
      (do-every timer relative-expiry-time repeat-period)
      (do-after timer relative-expiry-time)))

(defun %unschedule-timer% (timer)
  (mp:process-kill timer))

(defun invoke-with-timeout (seconds bodyfn timeoutfn)
  (block timeout
    (let* ((process mp:*current-process*)
           (timer (mp:process-run-function
                   "with-timeout-timer"
                   (lambda ()
                     (mp:process-sleep seconds)
                     (mp:process-interrupt process
                                           (lambda ()
                                             (return-from timeout
                                               (funcall timeoutfn))))))))
      (unwind-protect (funcall bodyfn)
        (mp:process-kill timer)))))

(defmacro %with-timeout% ((seconds &body timeout-forms) &body body)
  "Execute BODY; if execution takes more than SECONDS seconds,
terminate and evaluate TIMEOUT-FORMS."
  `(invoke-with-timeout ,seconds #'(lambda () ,@body)
                        #'(lambda () ,@timeout-forms)))