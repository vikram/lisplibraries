<html>

<head>
<title>AllegroServe</title>
<meta name="GENERATOR" content="Microsoft FrontPage 3.0">
</head>

<body>

<h1 align="center">AllegroServe - A Web Application Server<br>
<small><small><small>version <font face="Courier New">1.2.32</font></small></small></small></h1>

<p align="left"><strong><small>copyright(c) 2000-2003. Franz Inc</small></strong></p>

<h2 align="left">Table of Contents</h2>

<p align="left"><a href="#introduction">Introduction</a><br>
<a href="#running-AllegroServe">Running AllegroServe</a><br>
<a href="#starting-the-server">Starting the Server</a><br>
<font face="Courier New">&nbsp; <a href="#f-start">start</a></font><br>
<a href="#shutting-down-the-server">Shutting Down the Server</a><br>
<font face="Courier New">&nbsp; <a href="#f-shutdown">shutdown</a></font><br>
<a href="#publishing-information">Publishing Information</a><br>
<font face="Courier New">&nbsp; <a href="#f-publish-file">publish-file</a><br>
&nbsp;&nbsp;&nbsp; </font><a href="#entity-hook-function">Entity hook function</a><font
face="Courier New"><br>
&nbsp; <a href="#f-publish-directory">publish-directory</a><br>
&nbsp;&nbsp; </font>&nbsp; <a href="#directory-access-files">Directory Access Files</a><font
face="Courier New"><br>
&nbsp; <a href="#f-publish">publish</a></font><br>
&nbsp;&nbsp;&nbsp;&nbsp; <font face="Courier New"><a href="#f-publish-prefix">publish-prefix</a></font><br>
&nbsp;&nbsp;&nbsp;&nbsp; <a href="#f-publish-multi"><font face="Courier New">publish-multi</font></a><br>
<a href="#generating-a-computed-response">Generating a Computed Response</a><br>
<font face="Courier New">&nbsp; <a href="#f-with-http-response">with-http-response</a><br>
&nbsp; <a href="#f-with-http-body">with-http-body</a><br>
&nbsp; <a href="#f-get-request-body">get-request-body</a><br>
&nbsp; <a href="#f-header-slot-value">header-slot-value</a><br>
&nbsp; <a href="#f-reply-header-slot-value">reply-header-slot-value</a><br>
&nbsp; <a href="#f-request-query">request-query</a></font><br>
&nbsp;&nbsp;&nbsp;&nbsp; <font face="Courier New"><a href="#f-request-query-value">request-query-value</a></font><br>
<a href="#request-object-readers">Request Object Readers and Accessors</a><br>
<font face="Courier New">&nbsp; <a href="#f-request-method">request-method</a><br>
&nbsp; <a href="#f-request-uri">request-uri</a><br>
&nbsp; <a href="#f-request-protocol">request-protocol</a><br>
&nbsp; <a href="#f-request-socket">request-socket</a><br>
&nbsp; <a href="#f-request-wserver">request-wserver</a><br>
&nbsp; <a href="#f-request-raw-request">request-raw-request</a><br>
&nbsp; <a href="#f-request-reply-code">request-reply-code</a><br>
&nbsp; <a href="#f-request-reply-date">request-reply-date</a><br>
&nbsp; <a href="#f-request-reply-headers">request-reply-headers</a><br>
&nbsp; <a href="#f-request-reply-content-length">request-reply-content-length</a><br>
&nbsp; <a href="#f-request-reply-plist">request-reply-plist</a><br>
&nbsp; <a href="#f-request-reply-strategy">request-reply-strategy</a><br>
&nbsp; <a href="#f-request-reply-stream">request-reply-stream</a></font><br>
<a href="#cgi-program">CGI Program Execution</a><br>
<font face="Courier New">&nbsp; <a href="#f-run-cgi-program">run-cgi-program</a><br>
</font><a href="#form-processing">Form Processing</a><br>
<font face="Courier New">&nbsp; <a href="#f-get-multipart-header">get-multipart-header</a><br>
&nbsp; <a href="#f-parse-multipart-header">parse-multipart-header</a><br>
&nbsp; <a href="#f-get-multipart-sequence">get-multipart-sequence</a></font> <br>
&nbsp;&nbsp;&nbsp;&nbsp; <a href="#f-get-all-multipart-data"><font face="Courier New">get-all-multipart-data</font></a><br>
&nbsp;&nbsp;&nbsp;&nbsp; <font face="Courier New"><a href="#f-form-urlencoded-">form-urlencoded-to-query</a><br>
&nbsp; <a href="#f-query-to">query-to-form-urlencoded</a></font><br>
<a href="#authorization">Authorization</a><br>
<font face="Courier New">&nbsp; <a href="#f-get-basic-authorization">get-basic-authorization</a><br>
&nbsp; <a href="#f-set-basic-authorization">set-basic-authorization</a><br>
&nbsp; <a href="#c-password-authorizer">password-authorizer</a><br>
&nbsp; <a href="#c-location-authorizer">location-authorizer</a></font><br>
&nbsp;&nbsp;&nbsp;&nbsp; <a href="#c-function-authorizer"><font face="Courier New">function-authorizer</font></a><br>
<a href="#cookies">Cookies</a><br>
<font face="Courier New">&nbsp; <a href="#f-set-cookie-header">set-cookie-header</a><br>
&nbsp; <a href="#f-get-cookie-values">get-cookie-values</a></font><br>
<a href="#varaibles">Variables</a><br>
&nbsp;&nbsp;&nbsp;&nbsp; <font face="Courier New"><a href="#v-aserve-version">*aserve-version*</a><br>
&nbsp; <a href="#v-default-aserve-external-format">*default-aserve-external-format*</a><br>
&nbsp; <a href="#v-http-response-timeout">*http-response-timeout*</a><br>
&nbsp; <a href="#v-mime-types">*mime-types*</a></font><br>
<a href="#iseve-request-proc">AllegroServe Request Processing Protocol<br>
</a><font face="Courier New">&nbsp; <a href="#f-handle-request">handle-request</a><br>
&nbsp; <a href="#f-standard-locator">standard-locator</a><br>
&nbsp; <a href="#f-unpublish-locator">unpublish-locator</a><br>
&nbsp; <a href="#f-authorize">authorize</a><br>
&nbsp; <a href="#f-failed-request">failed-request</a><br>
&nbsp; <a href="#f-denied-request">denied-request</a><br>
&nbsp; <a href="#f-process-entity">process-entity</a></font><br>
<a href="#cliient-request">Client Functions</a><br>
<font face="Courier New">&nbsp; <a href="#f-do-http-request">do-http-request</a><br>
&nbsp; <a href="#c-client-request">client-request</a><br>
&nbsp; <a href="#c-cookie-jar">cookie-jar</a><br>
&nbsp; <a href="#f-make-http-client-request">make-http-client-request</a><br>
&nbsp; <a href="#f-read-client-response">read-client-response-headers</a><br>
&nbsp; <a href="#f-client-request-read-sequence">client-request-read-sequence</a><br>
&nbsp; <a href="#f-client-request-read-close">client-request-close</a><br>
&nbsp; <a href="#f-uriencode-string">uriencode-string</a></font><br>
<a href="#proxy">Proxy</a><br>
<a href="#cache">Cache</a><br>
<a href="#filters">Request Filters</a><br>
<a href="#virtual_hosts">Virtual Hosts</a><br>
<a href="#timeouts">Timeouts</a><br>
<font face="Courier New">&nbsp; <a href="#f-wserver-io-timeout">wserver-io-timeout</a><br>
&nbsp; <a href="#f-wserver-response-timeout">wserver-response-timeout</a></font><br>
<a href="#miscellaneous">Miscellaneous</a><br>
&nbsp;&nbsp;&nbsp;&nbsp; <font face="Courier New"><a href="#f-ensure-stream-lock">ensure-stream-lock</a></font><br>
&nbsp;&nbsp;&nbsp;&nbsp; <a href="#f-map-entities"><font face="Courier New">map-entities</font></a><br>
<a href="#asaservice">Running AllegroServe as a Service on Windows NT</a><br>
<a href="#international-chars-aserve">Using International Characters in AllegroServe</a><br>
<a href="#debugging">Debugging</a><br>
&nbsp;&nbsp;&nbsp;&nbsp; <font face="Courier New"><a href="#f-debug-on">net.aserve::debug-on</a><br>
&nbsp; <a href="#f-debug-off">net.aserve::debug-off</a></font><br>
<br>
<br>
</p>

<h2 align="left">In<a name="introduction"></a>troduction</h2>

<p><strong>AllegroServe </strong>is a webserver&nbsp; written at <a
href="http://www.franz.com">Franz Inc</a>.&nbsp;&nbsp;AllegroServe is designed to work
with the <a href="htmlgen.html">htmlgen</a> system for generating dynamic html, as one of
the big advantages of&nbsp; a web server written in Common Lisp is the ability to generate
html dynamically.&nbsp; In this document we'll consider the web server and dynamic html
generation to be parts of the same product.</p>

<p>The design goals of AllegroServe are: 

<ul>
  <li>a very small footprint.&nbsp;&nbsp; It should be possible to make AllegroServe a part of
    every application without being concerned about the impact of its size and processing
    requirements.</li>
  <li>simple configuration.&nbsp; AllegroServe should start automatically with minimal input
    from the user.&nbsp; </li>
  <li>easy to use.&nbsp;&nbsp; The typical scenarios should be easy to program with just
    knowledge of simple html.</li>
  <li>usable in commercial applications .</li>
  <li>support the latest http protocol (currently HTTP/1.1)</li>
  <li>runnable in multiple configurations.&nbsp;&nbsp;&nbsp; We want to support a program that
    just wants to make some part of it visible or configurable by one user through a web
    server.&nbsp; We also want to support&nbsp; a web site running on a multiprocessor taking
    many hits per second.&nbsp;&nbsp; Finally, we want to support levels in between those
    scenarios.</li>
</ul>

<p>&nbsp;</p>

<h2><a name="running-AllegroServe"></a>Running AllegroServe</h2>

<p>Running&nbsp; AllegroServe requires that you 

<ul>
  <li><strong>load</strong> <em>aserve.fasl</em> into Lisp</li>
  <li><strong>publish </strong>zero or more urls</li>
  <li><strong>start</strong> the server</li>
  <li><strong>publish </strong>zero or more urls</li>
</ul>

<p>We mention <strong>publish</strong> twice to emphasize that you can publish urls before
and after you start the server.</p>

<p>&nbsp;</p>

<h2><a name="starting-the-server"></a>Starting the server</h2>

<p>The function <font face="Courier New">net.aserve:start</font> is used to start the
server running.</p>

<p><strong><font face="Courier New"><a name="f-start"></a>(start &amp;key port host
listeners chunking keep-alive server setuid setgid <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; debug proxy proxy-proxy
cache restore-cache accept-hook ssl ssl-password<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; os-processes
external-format)</font></strong></p>

<p>If no arguments are given then <strong>start</strong>&nbsp; starts a multi-threaded web
server on port 80, which is the standard web server port.&nbsp;&nbsp;&nbsp; If you are
running this on Unix then you can only allocate port 80 if you are logged in as root or
have made Lisp a set-user-id root program.</p>

<p>There are quite a few keyword arguments to <strong>start</strong>, but in practice you
only need be concerned with <strong>:port</strong> and <strong>:listeners.
&nbsp;&nbsp;&nbsp; </strong>The arguments have the following meanings: 

<ul>
  <li>port -- the port on which to open the web server.&nbsp; 80 is the default.</li>
  <li>host -- the host on which to run the server.&nbsp; If you don't specify this then the
    server will listen on all TCP/IP network interfaces on the machine.&nbsp;&nbsp; If you
    specify &quot;localhost&quot; then the server willl only accept connections from the same
    machine.&nbsp;&nbsp; Other values for host can be used to run AllegroServe only a
    particular network interface.&nbsp; Host can be a name (like &quot;foo.franz.com&quot;), a
    dotted ip address &quot;192.168.0.1&quot; or an integer IP address.</li>
  <li>listeners -- the number of threads to process http requests.&nbsp;&nbsp;&nbsp;&nbsp; If
    a value isn't given for the <strong>:listeners</strong> argument then 5 is assumed. &nbsp;
    If&nbsp; the value is <strong>nil </strong>or <strong>0 </strong>then the server runs in <em>simple
    server mode<strong> </strong></em>in which the <strong>start</strong> function doesn't
    return - instead it processes the requests itself, one at a time.&nbsp; If a positive
    number is given as the value of <strong>:listeners</strong> then the server runs in <em>threaded
    server mode<strong>.</em> </strong>&nbsp; In this mode separate lisp lightweight processes
    are started to handle requests from clients, the number of request handing threads is
    equal to the value of the <strong>:listeners</strong> keyword argument.&nbsp; In this mode
    the <strong>start </strong>function returns after starting the other threads.</li>
  <li>chunking -- if true then the server will use the chunked transfer encoding when it's
    possible to do so.&nbsp; This is an optimization and should be left enabled unless you
    suspect that it is the cause of some sort of error.&nbsp;&nbsp; The default is true.</li>
  <li>keep-alive -- if true then the server will keep connections alive if requested by the
    web client, and if there are sufficient free threads to handle new requests coming in.
    &nbsp;&nbsp; This is an optimization and should be left on.&nbsp;&nbsp; The default is
    true.</li>
  <li>server -- if this is a passed a value it must be a <strong>wserver</strong> object,
    which denotes&nbsp; a particular instance of a web server.&nbsp;&nbsp; This is for support
    of running multiple independent web servers in the same lisp image.&nbsp; This will be
    described in a later section (eventually).</li>
  <li>setuid -- after opening the port, change the user id of this process to the given number
    (only numbers are allowed, not names).&nbsp; This will only have an effect on Unix and it
    will only succeed if the current user id is <strong>root</strong>.&nbsp;&nbsp; You would
    want to use this argument if you plan on opening port <strong>80</strong> on Unix, as you
    would have to start the server as <strong>root</strong> but then would want to change the
    user id to an account with fewer privileges before allowing possibly malicious people to
    connect to it.</li>
  <li>setgid -- after opening the port, change the group&nbsp; id of this process to the given
    number (only numbers are allowed, not names).&nbsp; This will only have an effect on Unix</li>
  <li>debug -- if given a number this will print debugging messages whose associated codes are
    this number or less.&nbsp;&nbsp;&nbsp; This is really an internal switch and may be
    removed in future versions.</li>
  <li>proxy -- if true then this server will also act as a proxy server and will forward http
    requests to other servers.</li>
  <li>proxy-proxy -- if <strong>proxy</strong> is also given a true value, then this argument
    determines where the proxy will forward&nbsp; requests.&nbsp; If proxy-proxy is nil then
    the requests go directly to the server given in the request.&nbsp; If proxy-proxy is
    given&nbsp; a value of a host and an optional port then the request is forwarded to the
    proxy server at that address.&nbsp;&nbsp; Valid values for proxy-proxy look like
    &quot;proxy.myfirm.com&quot; and &quot;localhost:8000&quot;.&nbsp;&nbsp; If no port is not
    specified, port 80 is assumed.</li>
  <li>cache -- if true (and if proxy is true as well) cache locally the work done by the proxy
    server.&nbsp; The value of this variable specifies the size of the caches, both memory and
    disk.&nbsp; See the section on caches for more details on the format of the argument.</li>
  <li>restore-cache - if given a value then this value should be the name of the file created
    by <strong>net.aserve:shutdown</strong> when given the <strong>save-cache</strong>
    argument.&nbsp;&nbsp; The state of the cache is restored as of when it was saved.
    &nbsp;&nbsp; This will only succeed if the external cache files that were in use when the <strong>shutdown</strong>
    was done are in exactly the same state they were when the <strong>shutdown </strong>was
    done.&nbsp;&nbsp; When the <strong>restore-cache</strong> argument is given, the value of
    the <strong>cache </strong>argument is ignored.</li>
  <li>accept-hook -- this should be a function of one argument, the socket which was created
    when a http request was accepted by AllegroServe.&nbsp; The function should return a
    socket for AllegroServe to use.&nbsp; This hook is normally used to turn a regular socket
    into an SSL socket.</li>
  <li>ssl - if true then it should be the name of PEM encoded file containing the server
    certificate and the associated private key.&nbsp; This causes the server to listen for SSL
    connections only.&nbsp; The default value of <strong>port</strong> is made 443 (rather
    than 80).&nbsp; This makes use of the <strong>accept-hook</strong> argument so if <strong>ssl</strong>
    is specified then <strong>accept-hook</strong> should not be specified.&nbsp;&nbsp; ssl is
    supported only in certain versions of Allegro CL.</li>
  <li>ssl-password - if the private key in the PEM encoded file referenced by the <strong>ssl</strong>
    argument is encrypted, then this is the key to decrypt it.</li>
  <li>os-processes - if given it should be an integer number of operating system processes in
    which to run AllegroServe.&nbsp; This is available on Unix only at the moment.&nbsp; The
    AllegroServes in different processes do <strong>not</strong> share a common Lisp heap..
    &nbsp; </li>
  <li>external-format - If given it should name the value to which
    *default-aserve-external-format* should be bound to when requests are processed.&nbsp; The
    default value is<strong> :latin1-base</strong></li>
</ul>

<p>&nbsp;</p>

<h2><a name="shutting-down-the-server"></a>Shutting down the server</h2>

<p><strong><font face="Courier New"><a name="f-shutdown"></a>(shutdown &amp;key server
save-cache)</font></strong></p>

<p>This shuts down the web server given (or the most recently started web server if no
argument is passed for <strong>server</strong>).&nbsp; If <strong>save-cache</strong> is
given then it should be the name of a file to which the current state of the proxy cache
will be written.&nbsp;&nbsp; The <strong>save-cache</strong> file will only contain
in-memory information about the cache.&nbsp; The cache usually consists of disk files as
well and in order to maintain the complete state of the cache these files must be saved by
the user as well.&nbsp; The information in the <strong>save-cache</strong> file refers to
the disk cache files so those disk cache files must exist and be in the same state and
location should the user choose to restore the state of the cache.</p>

<p>&nbsp;</p>

<h2><a name="publishing-information"></a>Publishing information</h2>

<p>Once the server is started it will accept requests from http clients, typically web
browsers.&nbsp;&nbsp; Each request is parsed and then AllegroServe searches for an object
to handle that request.&nbsp;&nbsp; That object is called an <strong>entity</strong>.&nbsp;
If an entity is found, it is passed the request and is responsible for generating and
sending a response to the client.&nbsp; If an entity can't be found then AllegroServe
sends back a response saying that that request was invalid.</p>

<p><em>Publishing</em> is the process of creating entities and registering them in the
tables scanned by AllegroServe after a request is read.</p>

<h3>Components of a request</h3>

<p>A request from an http client contains a lot of information.&nbsp; The two items that
determine which entity will handle the request are 

<ul>
  <li>the <strong>path</strong> of the url.&nbsp; This is the part of the url after the host
    name and before the query string (if any).&nbsp; For example in the url&nbsp; <font
    color="#0080FF"><u><strong>http://bar.com:8030/files/foo?xx=3&amp;yy=4</strong></u></font>
    the part we call the path&nbsp; is just <strong><font color="#0080FF">/files/foo</font>.<br>
    If </strong>the path contains escaped characters (e.g. /foo%20bar) then we replace the %xx
    in the path with the actual character before processing the request.&nbsp; Thus if you're
    publishing an entity to handle a uri such as <font color="#0080FF"><u><strong>http://www.machine.com/foo%20bar</strong></u></font>
    you should publish the path <strong>&quot;foo bar&quot;</strong> and <em>not</em> <strong>&quot;foo%20bar&quot;</strong>.</li>
  <li>the <strong>host</strong> to which the request is directed.&nbsp;&nbsp; This is not
    necessarily the host that is receiving the request due to virtual hosts and proxy
    servers.&nbsp; This value comes from the <strong>Host:</strong> header line, if one is
    given.&nbsp;</li>
</ul>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>A request contains other information and while that information isn't used to determine
which entity will handle the request it can be used by the entity handling the request in
any way it sees fit.</p>

<p>&nbsp;</p>

<p>The following functions create entities and specify which requests they will handle.
&nbsp;&nbsp; An entity is distinguished by the <strong>path</strong> and <strong>host</strong>
values passed to the particular <strong>publish</strong> function.&nbsp;&nbsp; When a <strong>publish</strong>
is done for a <strong>path</strong> and <strong>host</strong> for which there is already
an entity assigned, the old entity is replaced by the new entity.</p>

<p>&nbsp;</p>

<p><a name="f-publish-file"></a><strong><font face="Courier New">(publish-file &amp;key
path host port&nbsp; file content-type class preload cache-p remove <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
authorizer server timeout plist hook)</font></strong></p>

<p>This creates an entity that will return the contents of a file on the disk in response
to a request.&nbsp;&nbsp; The <strong>url</strong> and <strong>file</strong>&nbsp; must be
given, the rest of the arguments are optional..&nbsp; The arguments have these meanings: 

<ul>
  <li><strong>path </strong>-- a string that must match the name part of the url as described
    above in <strong>Components of a Request</strong></li>
  <li><strong>host -- </strong>normally <strong>nil</strong>.&nbsp; If you wish to do virtual
    hosting read <a href="#virtual_hosts">this section</a> describing how it's done.a</li>
  <li><strong>port</strong> -- this argument is currently unused and will likely be removed in
    future versions.</li>
  <li><strong>file </strong>-- the name of the file to return when a request to this entity is
    made.&nbsp;&nbsp; The file doesn't have to exist until the request is made unless <strong>preload</strong>
    is specified as true.</li>
  <li><strong>content-type</strong> -- A string describing the content of the file.&nbsp; This
    is often referred to as the MIME type of the file.&nbsp; An example is
    &quot;text/html&quot; to describe an html file.&nbsp; If a content-type value is not
    provided, then AllegroServe checks the pathname-type in the&nbsp; *mime-types* hash table
    to see if there is a content-type associated with this pathname-type.&nbsp; If it fails to
    find a content-type then it uses the type &quot;application/octet-stream&quot;.&nbsp; </li>
  <li><strong>class</strong> -- a Clos class name or class object to be used to hold this
    entity.&nbsp; The class must be a subclass of&nbsp; <strong>file-entity</strong>.
    &nbsp;&nbsp; </li>
  <li><strong>preload</strong> --if true it instructs <strong>AllegroServe</strong> to read
    the contents of the file in immediately and store it in a lisp object.&nbsp; This will
    speed up the response to this request.&nbsp; If the file on disk is updated AllegroServe
    will ignore the preloaded content and will access the content from disk.&nbsp;&nbsp; If <strong>preload</strong>
    is true then you most likely want to specify <strong>cache-p</strong> true as well.</li>
  <li><strong>cache-p</strong> -- if true then <strong>AllegroServe</strong> will cache the
    last value read for this file.&nbsp; When asked for this file <strong>AllegroServe</strong>
    will check to see if the file has changed on disk (using the last modified time as a
    measure).&nbsp; If the file hasn't changed AllegroServe will returned the cached value,
    otherwise <strong>AllegroServe</strong> will read in and cache the new contents of the
    file and will return that as a response.</li>
  <li><strong>remove </strong>-- instead of adding an entity, remove the entities that match
    the given <strong>path</strong> and <strong>host. </strong>This removes all entities, not
    just file entities.&nbsp; If a <strong>host</strong> value is not passed in an argument,
    then this will remove all entities for this <strong>path</strong>, regardless of their <strong>host</strong>
    values.</li>
  <li><strong>server</strong> -- if this entity should only be served by a particular server,
    then this specifies which server.&nbsp;&nbsp; See the section (to be written) on running
    multiple servers in the same Lisp process.</li>
  <li><strong>timeout</strong> - specifies the number of seconds AllegroServe has to return
    this file to the http client.&nbsp; If AllegroServe is running in a lisp that supports
    timeouts on each I/O operation (e.g. Acl 6.1 or newer) then the default value for this
    argument is a huge number, meaning in effect that there will be no time limit on the
    transfer.&nbsp;&nbsp; If I/O timeouts are not supported then the default value of this
    argument is <strong>nil</strong> meaning ignore this value and use the timeout value held
    in the server object and retrieved with<strong> wserver-response-timeout</strong>..</li>
  <li><strong>plist</strong> - initial property list for this entity</li>
  <li><strong>hook</strong> - a function of three arguments: req,ent and extra. &nbsp;&nbsp;
    See <a href="#entity-hook-function">entity hook function</a>.</li>
</ul>

<p>The function that handles requests for files will respond correctly to <strong>If-Modified-Since</strong>
header lines and thus minimizes network traffic. </p>

<p>Example: </p>

<p>This will work on Unix where the password file is stored in /etc.</p>

<pre>(publish-file :path &quot;/password&quot; :file &quot;/etc/passwd&quot; :content-type &quot;text/plain&quot;)</pre>

<h3><a name="entity-hook-function"></a>Entity Hook Function</h3>

<p>AllegroServe supplies many subclasses of entity which automatically generate a
responses to requests.&nbsp;&nbsp;&nbsp;&nbsp; There are times when user code needs to run
during the generation of&nbsp; a response by one of the built-in entity classes.
&nbsp;&nbsp; For example you may wish to add or modify the headers that will be sent back
with the <strong>publish-file</strong>'s response.&nbsp;&nbsp;&nbsp; The entity hook
function is called just before the<strong> with-http-body</strong> in the response
function.&nbsp; At this point all the response headers have been specified but the hook
function is free to change them or add new headers.</p>

<p>The entity hook function takes three arguments: <strong>req</strong>, <strong>ent</strong>
and <strong>extra</strong>.&nbsp;&nbsp; <strong>Req</strong> and <strong>ent</strong> are
the familiar http-request and entity arguments.&nbsp;&nbsp; <strong>Extra</strong> is
usually <strong>nil</strong> but will be one of the following symbols to tell&nbsp; the
hook function if it's being called in a special context.</p>

<table border="1" width="100%">
  <tr>
    <td width="21%"><strong>:illegal-range</strong></td>
    <td width="79%">request has asked for a range of bytes that is not present in the entity.
    &nbsp; As a result a &quot;416 - Illegal Range Specified&quot;&nbsp; response is being
    generated.</td>
  </tr>
  <tr>
    <td width="21%"><strong>:in-range</strong></td>
    <td width="79%">request has asked for a range of bytes and that range is being returned.</td>
  </tr>
  <tr>
    <td width="21%"><strong>:not-modified</strong></td>
    <td width="79%">request contains an &quot;If Not Modified&quot; header and AllegroServe is
    returning a &quot;304 - Not Modified&quot; response.</td>
  </tr>
</table>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p><a name="f-publish-directory"></a><strong><font face="Courier New">(publish-directory
&amp;key prefix host port destination remove authorizer server <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
indexes filter timeout plist publisher access-file<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
hook)</font></strong></p>

<p><strong>publish-directory</strong> is used to publish a complete directory tree of
files.&nbsp; This is similar to how web servers such as Apache publish files. &nbsp;
AllegroServe publishes the files in&nbsp; the directory tree in a <em>lazy</em>
manner.&nbsp;&nbsp; As files in the tree are referenced by client requests entities are
created and published.&nbsp; </p>

<p><strong>publish-directory</strong> creates a mapping from all urls whose name begins
with<strong> prefix</strong> to files stored in the directory specified by the <strong>destination</strong>.&nbsp;&nbsp;
The <strong>host</strong>, <strong>port, remove, authorizer, plist, hook </strong>and <strong>server</strong>
arguments are as described above for <strong>publish-file.</strong>
&nbsp;&nbsp;&nbsp;&nbsp; The <strong>timeout</strong> argument defaults as described in <strong>publish-file</strong>.
&nbsp;The <strong>hook</strong> argument specifies what hook function should be put in the
entities that <strong>publish-directory</strong> creates.&nbsp;&nbsp; The <strong>access-file</strong>
argument names the <a href="#directory-access-files">access file</a> name which will be
used in this directory tree. When a request comes in for which there isn't an entity that
matches it exactly,&nbsp; AllegroServe checks to see if a prefix of the request has been
registered.&nbsp; If so, and if the resulting entity is a <strong>directory-entity</strong>
as created by this function, then it strips the prefix off the given request and appends
the remaining part of the request to the destination string.&nbsp; It then publishes that
(normally using <strong>publish-file</strong> and computing the content-type from the file
type). &nbsp;&nbsp; Next that <strong>file-entity </strong>is made to handle the request
in the normal manner.</p>

<p>If a request comes that maps to a directory rather than a file then AllegroServe tries
to locate an index file for that directory.&nbsp; The <strong>indexes</strong> argument
specifies a list of index files to search for.&nbsp; By default the list consists of two
filenames &quot;index.html&quot; and &quot;index.htm&quot;.</p>

<p>The valueof the <strong>filter </strong>argument is a function of four values: <strong>req</strong>
<strong>ent</strong>&nbsp; <strong>filename</strong> and <strong>info</strong>.&nbsp; <strong>req</strong>
and <strong>ent</strong> are the request and entity objects that describe the current
client request. &nbsp;&nbsp;&nbsp; <strong>filename</strong> is the name of a known file
on the current machine which&nbsp; is being requested by the current request.&nbsp; <strong>info</strong>
is the list of <a href="#directory-access-files">access information</a> for this file.</p>

<p>If the filter returns <strong>nil</strong> then the normal operation&nbsp; is done by
the directory-entity handler: the selected file is published and then the request to
access it processed (and subsequent access using that url will just return the file and
never go through the filter again).</p>

<p>If the filter chooses to handle the request for the file itself&nbsp; it must generate
a response to the request and then return a non-nil value.&nbsp; To avoid subsequent calls
to the filter for this file the filter may choose to publish a handler for this url.
&nbsp; If the filter wants to forbid access to this file a handy way to to call <font
face="Courier New">(failed-request req)</font> and the standard &quot;404 Not found&quot;
will be sent back to the client.</p>

<p>The <strong>publisher</strong> argument can be used to specify exactly what happens
when a request comes that's handled by the <strong>directory-entity </strong>and a file is
located on the disk that matches the incoming <strong>url</strong>.&nbsp;&nbsp; Nomally a <strong>publish-file</strong>
is done to add that file.&nbsp; You may want to publish some other kind of entity to
represent that file.&nbsp; The <strong>publisher</strong> argument, if non-nil, must be a
function of&nbsp; four arguments:&nbsp; <strong>req ent filename</strong> <strong>info</strong>.&nbsp;
The filename is a string naming the file that's been matched with the request.&nbsp;&nbsp;
<strong>info</strong> is the list of <a href="#directory-access-files">access information</a>
for this file.&nbsp; The <strong>publisher</strong> function must return an entity to be
processed to send back a response.&nbsp;&nbsp; The <strong>publisher</strong> function may
wish to publish that entity but it need not do so.</p>
<div align="center"><center>

<table border="1" width="86%" cellpadding="5">
  <tr>
    <td width="100%">Note:&nbsp; <strong>publish-directory</strong> is a more general function
    than its name implies.&nbsp;&nbsp;&nbsp; It looks at each url path for a match for <strong>prefix
    </strong>and if such a match is found the <strong>prefix</strong> is removed and replaced
    with <strong>destination</strong>.&nbsp;&nbsp; Thus is prefix is <strong>&quot;/foo&quot;</strong>
    and destination is <strong>&quot;/bar&quot;</strong> then a url path of&nbsp; <strong>&quot;/foobaz/joe.html&quot;
    </strong>would be converted to <strong>&quot;/barbaz/joe.html&quot;.</strong>
    &nbsp;&nbsp;&nbsp; This is rarely useful but it does show that you have to be careful
    about the prefix and destination strings.&nbsp; It's usually the case that if the prefix
    string ends in <strong>&quot;/&quot;</strong> then the destination string should end in <strong>&quot;/&quot;</strong>
    (and vice versa).&nbsp; Thus a prefix of <strong>&quot;/foo&quot;</strong> would have a
    destination of <strong>&quot;/bar&quot; </strong>and a prefix of <strong>&quot;/foo/&quot;</strong>
    would have a destination of <strong>&quot;/bar/&quot;</strong>.&nbsp; </td>
  </tr>
</table>
</center></div>

<p>&nbsp;</p>

<h3><a name="directory-access-files"></a>Directory Access Files</h3>

<p>When files are accessed and automatically published you may wish to set some of the
parameters of the entity that is published. As mentioned above you can define a <strong>publisher</strong>
function that has complete control in publishing the entity.&nbsp; A less powerful but
easier to use alternative is to place <em>access files </em>in the directory tree being
published.&nbsp;&nbsp; An access file specifies information that you want passed to the
publisher function.&nbsp; You can modify these access files while the directory tree is
published and their latest values will be used for publishing <em>subsequent</em> files.
&nbsp;&nbsp; This is similar to they way Apache controls its publishing with <strong>.htaccess</strong>
files (except that in AllegroServe once a file is published the access files have no
effect on it).</p>

<p>The name of an access file in AllegroServe is controlled by the <strong>:access-file</strong>
argument to <strong>publish-directory.</strong>&nbsp;&nbsp; We'll assume the name chosen
is <strong>access.cl</strong> in this document.&nbsp;&nbsp; If no <strong>:access-file</strong>
argument is given to <strong>publish-directory</strong> then no access file checking is
done. &nbsp;When a file is about to be published all access files from the <strong>destination</strong>
directory all the way down to the directory containing the file to be published are read
and used.&nbsp; For example if the <strong>destination</strong> in a <strong>publish-directory
</strong>was given as &quot;/home/joe/html/&quot; and an http request comes in which
references the file &quot;/home/joe/html/pics/archive/foo.jpg&quot;&nbsp; then
AllegroServe will check for access files at <em>all</em> of these locations and in this
order 

<ul>
  <li>/home/joe/html/access.cl</li>
  <li>/home/joe/html/pics/access.cl</li>
  <li>/home/joe/html/pics/archive/access.cl</li>
</ul>

<p>The information is collected as successive access files are read.&nbsp; The new
information is placed before the existing information thus causing subdirectory &nbsp;
access files to possibly shadow information in access files in directories above it.&nbsp;
Also superdirectory access file information is automatically eliminated if it isn't marked
as being <em>inherited<strong>.&nbsp; </strong></em></p>

<p>The <strong>publisher </strong>function receives the collected information and can do
with it what it wishes.&nbsp; We'll describe what the built-in publisher function does
with the information.</p>

<p>When we speak of <em>information<strong> </strong></em>in access files we are purposely
being vague.&nbsp;&nbsp; We define what information must look like and what the standard
publisher function does with certain information but we allow users to define their own
kinds of information and use that in their own publisher function.</p>

<p>Each access file consists of zero or more Lisp forms (and possibly lisp style
comments).&nbsp; Each form is&nbsp; a list beginning with a keyword symbol and then
followed by a property-list-like sequence of &nbsp; keywords and values.&nbsp;&nbsp;
Nothing in the form is evaluated. &nbsp;&nbsp;&nbsp; The form cannot contain #. or #,.
macros.</p>

<p>One&nbsp; information form is used by AllegroServe's directory publisher code to decide
if it's permitted to descend another directory level:</p>

<p><strong>(:subdirectories&nbsp; :allow </strong><em>allow-list</em><strong> :deny </strong><em>deny-list</em><strong>
:inherit </strong><em>inherit-value</em><strong>)</strong></p>

<p>As AllegroServe descends from the <strong>destination</strong> directory toward the
directory containing the file to be accessed it stops at each directory level accumlates
the access information and then tests to see if it can descend further based on the <strong>:subdirectories
</strong>information.&nbsp;&nbsp; If it cannot descend into the next subdirectory it gives
up immediately and a <strong>404 - Not Found</strong> response is returned. &nbsp;&nbsp;
See the section Allow Deny processing below for a description of how it uses the <strong>:allow</strong>
and <strong>:deny</strong> values.</p>

<p>These other information forms are used by the standard publisher function. &nbsp;&nbsp;
Each takes an <strong>:inherit</strong> argument which defaults to false. &nbsp;
Information not given with :<strong>:inherit t</strong> will be eliminated as AllegroServe
descends directory levels.</p>

<table border="1" width="100%">
  <tr>
    <th width="15%">name</th>
    <th width="17%">args</th>
    <th width="68%">meaning</th>
  </tr>
  <tr>
    <td width="15%"><strong>:ip</strong></td>
    <td width="17%"><strong>:patterns <br>
    :inherit</strong></td>
    <td width="68%">specifies a<a href="#c-location-authorizer"> location-authorizer</a>
    restriction on which machines can see published files.&nbsp; The value of the <strong>:patterns</strong>
    argument has the same form as the <strong>:patterns</strong> slot of a
    location-authorizer.</td>
  </tr>
  <tr>
    <td width="15%"><strong>:password</strong></td>
    <td width="17%"><strong>:realm<br>
    :allowed<br>
    :inherit</strong></td>
    <td width="68%">specifies a <a href="#c-password-authorizer">password-authorizer</a>
    restriction on access to published files. &nbsp; See the password-authorizer documentation
    for a description of the <strong>:realm</strong> and <strong>:allowed</strong> arguments</td>
  </tr>
  <tr>
    <td width="15%"><strong>:files</strong></td>
    <td width="17%"><strong>:allow<br>
    :deny<br>
    :inherit</strong></td>
    <td width="68%">specifies which files are visible to be published.&nbsp; To be visible a
    file must be allowed and not denied.&nbsp; What is tested is the filename only (that is
    the part after the last directory separator in the files's complete name).&nbsp; See below
    for the rules on how allow and denied is used.</td>
  </tr>
  <tr>
    <td width="15%"><strong>:mime</strong></td>
    <td width="17%"><strong>:types<br>
    :inherit</strong></td>
    <td width="68%">specifies which mime types are to be associated with which file types.
    &nbsp; This list takes precedence over the built-in list inside AllegroServe.&nbsp; :types
    is a list of mime specifiers.&nbsp;&nbsp; A mime specifier is a list beginning with a
    string giving the mime type followed by the files types that should map to that mime type.
    &nbsp; A file type in a list (e.g. (&quot;ReadMe&quot;)) refers to the whole file name
    rather than the type component.</td>
  </tr>
</table>

<h3>Allow and Deny Processing</h3>

<p>The <strong>:files </strong>and <strong>:subdirectories</strong> information are used
to determine if a file or subdirectory of a given name is accessible.&nbsp; AllegroServe
will collect all the access file information for the directory containing the file or
subdirectory and for all directories above it up to the directory given as the <strong>destination</strong>
argument to <strong>publish-directory.&nbsp; </strong>Information from superdirectories
will only be used <strong>:inherit t</strong> is given for that information.&nbsp; </p>

<p>The rules is it that a given name is accessible if it is allowed and not denied. &nbsp;
That is the filename or directory name must match one of the allow clauses and none of the
deny clauses.&nbsp; There may be multiple allow and deny clauses since there may be
multiple information forms of the type <strong>:files </strong>or <strong>:subdirectories</strong>.
&nbsp;&nbsp; Each allow or deny argument can be a string or a list of strings or nil
(which is the same as that argument not being given).<strong> </strong>&nbsp; The strings
are regular expressions (which are not exactly like unix shell wildcard filename
expressions).&nbsp;&nbsp; In particular <font face="Courier New">&quot;.*&quot;</font> is
the regular expression that matches anything.</p>

<p>The special cases are the following 

<ul>
  <li>if <strong>:allow</strong> is given as nil or is not given at all then that is the same
    as specifying <font face="Courier New">&quot;.*&quot;</font> the regular expression that
    matches everything.</li>
  <li>if <strong>:deny</strong> is given as nil or is not given then that is the same as
    specifying a regular expression that matches nothing.</li>
  <li>if AllegroServe is looking for <strong>:files </strong>information and there is none to
    be found in the accumulated information, then access is allowed.&nbsp;&nbsp; A similar
    thing is true if AllegroServe is searching for <strong>:subdirectories</strong>
    information and none is found.</li>
</ul>

<p>&nbsp;</p>

<p>.</p>

<p>Here is a sample access file:</p>

<p><font face="Courier New">; only connections to localhost will be able to access the
files<br>
(:ip :patterns ((:accept &quot;127.1&quot;) :deny) :inherit t)&nbsp;&nbsp;&nbsp; <br>
(:password :realm &quot;mysite&quot; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :allowed ((&quot;joe&quot; .
&quot;mypassword&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(&quot;sam&quot; . &quot;secret&quot;)) <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :inherit t) ;&nbsp; applies
to subdirectories<br>
; publish html and cgi files, but not those beginning with a period<br>
(:files :allow (&quot;\\.html$&quot; &quot;\\.cgi$&quot;) :deny (&quot;^\\.&quot;)) <br>
; specify mime type for non-standard file extensions.&nbsp; Also<br>
; specify that a file named exactly ChangeLog should be given<br>
; mime type &quot;text/plain&quot;<br>
(:mime :types ((&quot;text/jil&quot; &quot;jil&quot; &quot;jlc&quot;)
(&quot;text/plain&quot; &quot;cl&quot; (&quot;ChangeLog&quot;))))</font></p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p><a name="f-publish"></a><strong><font face="Courier New">(publish &amp;key path host
port content-type function class format remove server authorizer timeout plist hook)</font></strong></p>

<p>This creates a mapping from a url to a <strong>computed-entity</strong>, that is an
entity that computes its response every time a request comes in.&nbsp; The <strong>path</strong>,
<strong>host</strong>, <strong>port</strong>, <strong>remove, server</strong> , <strong>authorizer,
hook </strong>and <strong>class</strong> arguments are as in the other publish
functions.&nbsp;&nbsp;The <strong>timeout</strong> argument defaults to <strong>nil </strong>always.&nbsp;&nbsp;
The <strong>content-type</strong> sets a default value for the response to the request but
this can be overridden.&nbsp; The <strong>format</strong> argument is either <strong>:text
</strong>(the default) or <strong>:binary</strong> and it specifies the kind of value that
will be sent back (after the response headers, which are always in text).&nbsp;&nbsp; This
value is only important if the response is generated in a particular way (described
below).&nbsp;&nbsp; The value of the<strong> hook</strong> argument is stored in the
entity created however the hook function will only be run if the <strong>function</strong>
supplied makes use of it.</p>

<p>The <strong>function </strong>argument is&nbsp; a function of two arguments: an object
of class <strong>http-request</strong> that holds a description of the request, and an
object of class <strong>entity </strong>that holds this entity which is handling the
request.&nbsp;&nbsp; This function must generate a response to the http request, even if
the response is only that the request wasn't found.</p>

<p>&nbsp;</p>

<p><a name="f-publish"></a><a name="f-publish-prefix"></a><strong><font face="Courier New">(publish-prefix
&amp;key prefix host port content-type function class <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
format remove server authorizer timeout plist hook)</font></strong></p>

<p>This is like <strong>publish </strong>except that it declares <strong>function</strong>
to be the handler for all urls that begin with the string <strong>prefix</strong>.
&nbsp;&nbsp; Note however that prefix handlers have lower priority than exact handlers.
&nbsp; Thus if you declare a prefix handler for &quot;/foo&quot; and also a specific
handler for &quot;/foo/bar.html&quot; then the specific handler will be chosen if
&quot;/foo/bar.html&quot; is found in an http request.&nbsp;&nbsp; Typically a prefix
handler is used to make available a whole directory of files since their complete names
being with a common prefix (namely the directory in which the files are located).
&nbsp;&nbsp; If you want to publish a whole directory then you probably want to use <strong>publish-directory</strong>
since it has a number of features to support file publishing.&nbsp;&nbsp; The value of the<strong>
hook</strong> argument is stored in the entity created however the hook function will only
be run if the <strong>function</strong> supplied makes use of it.</p>

<p>&nbsp;</p>

<p><a name="f-publish-multi"></a><strong><font face="Courier New">(publish-multi &amp;key
path host port content-type items class remove server authorizer timeout hook)</font></strong></p>

<p>Some web pages are created from information from various sources.&nbsp;&nbsp; <strong>publish-multi</strong>
allows you to specify a sequence of places that supply data for the combined web page.
&nbsp; The data for each page is cached by <strong>publish-multi</strong> so that minimal
computation is required each time the page is requested.&nbsp;&nbsp;&nbsp; </p>

<p>The <strong>host, port, content-type, class, remove, server, authorizer, hook </strong>and<strong>
timeout</strong> arguments are the same as those of the other publish functions.
&nbsp;&nbsp; The <strong>items </strong>argument is unique to <strong>publish-multi</strong>
and is a list of zero or more of the following objects 

<ul>
  <li>string or pathname - this is a reference to a file on the server.&nbsp; This item
    contributes the contents of the file to the final web page.</li>
  <li>symbol or function - this is a function of four arguments: <strong>req ent cached-time
    cached-value</strong>.&nbsp;&nbsp; It returns two values:&nbsp; the new value and the last
    modified time of the value.&nbsp;&nbsp; The function may look at the cached-value or
    cached-time and realize that nothing has changed since that time that would cause this
    function to return a new value.&nbsp; In that case it should return the cached-value and
    cached-time that it received as arguments.&nbsp;&nbsp; If a value must always be computed
    each time the function is called it may return <strong>nil</strong> for the last modified
    time.&nbsp; This will result in no LastModified header being sent in the response.
    &nbsp;&nbsp; The value the function returns can either be a string or an array of
    unsigned-byte 8 values.&nbsp;&nbsp; It's preferred to return an array of unsigned-byte 8
    values.&nbsp; If a string is returned then<strong> </strong>it will be converted to an
    array of unsigned-byte 8 by using <strong>(string-to-octets string :null-terminate nil).
    &nbsp;&nbsp; </strong>The cached-value argument to the function will be <strong>nil</strong>
    or an unsigned-byte 8 array.</li>
  <li><strong>(:string</strong> string<strong>) - </strong>this item supplies the given string
    to the web page.</li>
  <li>(<strong>:binary</strong> vector) - vector should be a one dimensional simple-array of
    (unsigned-byte 8).&nbsp; This vector of bytes is added to the web page.</li>
</ul>

<p>Here's an example where we create a page from a fixed header and trailer page with a
bit of dynamic content in the middle.</p>

<pre>(publish-multi :path &quot;/thetime&quot;
	       :items (list &quot;header.html&quot;
			    #'(lambda (req ent old-time old-val)
				(declare (ignore req ent old-time old-val))
				(with-output-to-string (p)
				  (html-stream p
					       :br
					       &quot;The time is &quot;
					       (:princ (get-universal-time))
					       (:b
						&quot;Lisp Universal Time&quot;)
					       :br)))
			    &quot;footer.html&quot;))
				   </pre>

<h2><a name="generating-a-computed-response"></a>Generating a computed response </h2>

<p>There are a variety of ways that a response can be sent back to the http client
depending on whether keep-alive is being done, chunking is possible, whether the response
is text or binary, whether the client already has the most recent data, and whether the
size of the body of the response is known before the headers are sent.&nbsp; AllegroServe
handles the complexity of determining the optimal response strategy and the user need only
use a few specific macros in the computation of the response in order to take advantage of
AllegroServe's strategy computation</p>

<p>Here's a very simple computed response.&nbsp; It just puts &quot;Hello World!&quot; in
the browser window:</p>

<pre>(publish :path &quot;/hello&quot;
         :content-type &quot;text/html&quot;
         :function #'(lambda (req ent)
                       (with-http-response (req ent)
                          (with-http-body (req ent)
                             (html &quot;Hello World!&quot;)))))



</pre>

<p align="left">This example works regardless of whether the request comes in from an old
HTTP/0.9 browser or a modern HTTP/1.1 browser.&nbsp; It may or may not send the response
back with Chunked transfer encoding and it may or may not keep the connection alive after
sending back the response.&nbsp;&nbsp; The user code doesn't have to deal with those
possibilities, it just uses <strong>with-http-response</strong> and <strong>with-http-body</strong>
and the rest is automatic.&nbsp; The <strong>html</strong> macro is part of the htmlgen
package that accompanies AllegroServe.&nbsp;&nbsp; In the case above we are being lazy and
not putting out the html directives that should be found on every page of html since most
browsers are accommodating.&nbsp;&nbsp; Here's the function that generates the correct
html:</p>
<div align="left">

<pre>(publish :path &quot;/hello2&quot;
         :content-type &quot;text/html&quot;
         :function #'(lambda (req ent)
                       (with-http-response (req ent)
                         (with-http-body (req ent)
                          (html 
                             (:html
                               (:body &quot;Hello World!&quot;)))))))</pre>
</div>

<p align="left">&nbsp;</p>

<p align="left">The function above generates: <font face="Courier New">&lt;html&gt;&lt;body&gt;Hello
World!&lt;/body&gt;&lt;/html&gt;.</font></p>

<p align="left">&nbsp;</p>

<p align="left">The macros and functions used in computing responses are these:</p>

<hr>

<p align="left"><a name="f-with-http-response"></a><strong><font face="Courier New">(with-http-response
(req ent &amp;key timeout check-modified format response content-type) <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&amp;rest body)</font></strong></p>

<p align="left">This macro begins the process of generating a response to an http request
and then&nbsp; runs the code in the <strong>body</strong> which will actually send out the
response.&nbsp; <strong>req</strong> and <strong>ent</strong> are the request and entity
objects passed into the function designated to compute the response for the request.
&nbsp;&nbsp;&nbsp; <strong>timeout </strong>sets a time limit for the computation of the
response.&nbsp;&nbsp; If <strong>timeout</strong> is nil then the entity <strong>ent</strong>
is checked for a timeout value.&nbsp; If that value is also nil then the timeout value is
retreived from the current <strong>wserver</strong> object using <strong>wserver-response-timeout</strong>.
&nbsp; If <strong>check-modified </strong>is true (the default) then the <strong>last-modified
</strong>time stored in the entity object will be compared against the <strong>if-modified-since
</strong>time of the request and if that indicates that the client already has the latest
copy of this entity then a <strong>not-modified</strong> response will be automatically
returned to the client and the <strong>body </strong>of this macro will not be
run.&nbsp;&nbsp; <strong>response </strong>is an object containing the code and
description of the http response we wish to return. &nbsp;&nbsp; The default value is the
value of <strong>*response-ok*</strong> (which has a code of 200 and a string descriptor
&quot;OK&quot;).&nbsp;&nbsp; <strong>content-type </strong>is a string describing the MIME
type of the body (if any) sent after the headers.&nbsp; It has a form like
&quot;text/html&quot;.&nbsp;&nbsp; If <strong>content-type</strong> isn't given here then
the content-type value in the entity (which is set in the call to <strong>publish)</strong>
will be used.</p>

<p align="left">The <strong>format</strong> argument specifies whether the code that
writes the body of the response will want to write <strong>:text</strong> (e.g. <strong>write-char</strong>)
or <strong>:binary</strong> (e.g. <strong>write-byte</strong>) when it writes the data of
the body of the response. &nbsp;&nbsp;&nbsp;&nbsp; Based on the value of the <strong>format</strong>
argument, AllegroServe will create the correct kind of response stream.&nbsp;&nbsp; If <strong>format
</strong>is not specified here it will default to the value specified when <strong>publish</strong>
was called to create the entity.&nbsp; If not <strong>:format </strong>argument was passed
to <strong>publish</strong> then <strong>:binary</strong> format is assumed.
&nbsp;&nbsp;&nbsp; If <strong>:binary</strong> is specified then you can write both text
and binary to the stream&nbsp; since Allegro's binary streams also support text calls as
well.&nbsp; If you specify <strong>:text</strong> then you may end up with a stream that
supports only text operations.</p>

<p align="left">An http response consists of a line describing the response code, followed
by headers (unless it's the HTTP/0.9 protocol in which case there are no headers),
&nbsp;&nbsp; and then followed by the body (if any) of the response.&nbsp;&nbsp; <strong>with-http-response</strong>
doesn't normally send anything to the client.&nbsp; It only does so when it determines
that the <strong>if-modified-since</strong> predicate doesn't hold and that it must send
back a <strong>not-modified</strong> response.&nbsp;&nbsp;&nbsp; Thus&nbsp; is not enough
to just call <strong>with-http-response</strong> in your response function.&nbsp; You must
always call <strong>with-http-body </strong>inside the call to <strong>with-http-response</strong>.</p>

<p align="left">&nbsp;</p>

<hr>

<p align="left"><a name="f-with-http-body"></a><strong><font face="Courier New">(with-http-body
(req ent &amp;key format headers external-format)&nbsp; &amp;rest body)</font></strong></p>

<p align="left">This macro causes the whole http response to be sent out.&nbsp; The macro
itself will send out everything except the body of the response.&nbsp; That is the
responsibility of the code supplied as the <strong>body </strong>form of the macro.
&nbsp;&nbsp;&nbsp; In cases where there is no body to the response being sent it is still
necessary to call <strong>with-http-body </strong>so that the other parts of the response
are sent out, e.g.<font face="Courier New"> </font>at a minimum you should put<font
face="Courier New"> (with-http-body (req ent)) </font>in the body of a with-http-response.</p>

<p align="left"><em>The <strong>body </strong>forms may not be executed! </em>If the
request is an http <strong>head</strong> request then the browser wants only the headers
returned.&nbsp;&nbsp; The <strong>with-http-body </strong>macro will not evaulate the <strong>body</strong>
forms.&nbsp;&nbsp; You must be aware of this and should never put code in the <strong>body
</strong>form that absolutely must be executed when a request is given.</p>

<p align="left">The <strong>headers</strong> argument is a list of conses, where the car
is the header name (a keyword symbol) and the cdr is the header value.&nbsp; These headers
are added to the headers sent as part of this response.</p>

<p align="left">Within the <strong>body </strong>forms the code calls <strong>(request-reply-stream
req)</strong> to obtain a stream to which it can write to supply the body of the response.
&nbsp; The external-format of this stream is set to the value of the <strong>external-format</strong>
argument (which defaults to the value of <strong>*default-aserve-external-format*</strong>).&nbsp;&nbsp;
The variable <strong>*html-stream*</strong> is bound to the value of <strong>(request-reply-stream
req)</strong> before the <strong>body</strong> is evaluated.&nbsp;&nbsp; This makes it
easy&nbsp; to use the <strong>html</strong> macro to generate html as part of the
response. </p>

<p align="left"><em>Note: there used to be a <strong>:format</strong> argument to <strong>with-http-body.
</strong>That argument was never used by <strong>with-http-body</strong>.&nbsp; The <strong>:format
</strong>argument has been moved to <strong>with-http-response </strong>so that it can now
have an effect on the stream created.</em></p>

<hr>

<p><a name="f-get-request-body"></a><strong><font face="Courier New">(get-request-body
request &amp;key external-format)</font></strong></p>

<p>Return the body of the request as a string.&nbsp; If there is no body the return value
will be an empty string.&nbsp;&nbsp; The result is cached inside the request object, so
this function can be called more than once while processing a request.&nbsp;&nbsp; The
typical reason for there to be a body to a request is when a web browser sends the result
of a form with&nbsp; a POST method.&nbsp;&nbsp; The octets that make up the body of the
request are converted to a string (and then cached) using the <strong>:octets</strong>
external format as this is the appropriate external format if the request body contains a
list of form values.</p>

<p>If an <strong>external-format</strong> is specified the body is reconverted to a string
using the given external-format and then returned from this function.&nbsp;&nbsp; This
reconversion does not affect the cached value.</p>

<hr>

<p><a name="f-header-slot-value"></a><strong><font face="Courier New">(header-slot-value
request header-name)</font></strong></p>

<p>Return the value given in the request for the given header-name (a keyword symbol).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If the header wasn't present in this request then nil will
be returned.&nbsp;&nbsp; <strong>header-slot-value</strong> is a macro that will expand
into a fast accessor if the <strong>header-name</strong> is a constant naming a known
header slot</p>

<p>I<em>n older versions of aserve the<strong> header-name</strong> was a string..</em></p>

<p>&nbsp;</p>

<hr>

<p><a name="f-reply-header-slot-value"></a><font face="Courier New"><strong>(reply-header-slot-value
request header-name)</strong></font></p>

<p>Return the value associated with the header <strong>header-name</strong> in the reply
sent back to the client.&nbsp; This function is setf'able and this is the preferred way to
specify headers and values to be sent with a reply.</p>

<hr>

<p><a name="f-request-query"></a><strong><font face="Courier New">(request-query request
&amp;key uri post external-format)</font></strong></p>

<p>Decode and return an alist of the query values in the request.&nbsp;&nbsp; Each item in
the alist is a cons where the car is a string giving the name of the argument and the cdr
is a string giving the value of the argument.</p>

<p>The query string is in one or both of two places: 

<ul>
  <li>it begins at the first question mark in the uri and continues until the end of the uri
    or a sharp sign (#), whichever comes first.</li>
  <li>it is in the body of a POST request from a web client.</li>
</ul>

<p><strong>request-query</strong> will by default look in both locations for the query
string and concatenate the results of decoding both query strings.&nbsp; If you would like
it to not check one or both of the locations you can use the <strong>:uri</strong> and <strong>:post</strong>
keyword arguments.&nbsp;&nbsp; If <strong>uri</strong> is true (and true is the default
value) then the query string in the uri is checked.&nbsp; If <strong>post</strong> is true
(and true is the default value) and if the request is a POST then the body of the post
form will be decoded for query values.</p>

<p>The <strong>external-format</strong> is used in the conversion of bytes in the form to
characters.&nbsp; It defaults to the value of <strong>*default-aserve-external-format*</strong>.</p>

<p>A query is normally a set of names and values.&nbsp; <br>
<strong>http://foo.com/bar?a=3&amp;b=4 </strong>yields a query alist <strong>((&quot;a&quot;
. &quot;3&quot;) (&quot;b&quot; . &quot;4&quot;)). </strong><br>
If a name doesn't have an associated value then the value in the alist is the empty
string.&nbsp;<br>
<strong>http://foo.com/bar?a&amp;b=&amp;c=4</strong> &nbsp; yields a query alist <strong>((&quot;a&quot;
. &quot;&quot;) (&quot;b&quot; . &quot;&quot;) (c . &quot;4&quot;))</strong></p>

<p>.&nbsp;&nbsp; </p>

<p><a name="f-request-query-value"></a><font face="Courier New"><strong>(request-query-value
key request &amp;key uri post external-format test)</strong></font></p>

<p>This combines a call to <strong>request-query</strong> to retrieve the alist of query
keys and values, with a call to <strong>assoc</strong> to search for the specific key, and
finally with a call to <strong>cdr</strong> to return just the value from the assoc list
entry.&nbsp; The <strong>test</strong> argument is the function to be used to test the
given key against the keys in the assoc list. It defaults to <strong>#'equal</strong>. </p>

<p>If the given key is <em>not</em> present in the query <strong>nil</strong> is returned.
&nbsp; If the given key <em>is</em> present in the query but doesn't have an associated
value then the empty string is returned.</p>

<hr>

<p>&nbsp;</p>

<h2><a name="request-object-readers"></a>Request Object Reader and Accessors</h2>

<p>The request object contains information about the http request being processed and it
contains information about the response that is being computed and returned to the
requestor.&nbsp;&nbsp; The following functions access slots of the request object. &nbsp;
Those with names beginning with <strong>request-reply-</strong> are accessing the slots
which hold information about the response to the request.&nbsp;&nbsp; When a function is
listed as an<em> accessor<strong> </strong></em>that means that it can be <strong>setf</strong>'ed
as well as used to read the slot value.</p>

<p>&nbsp;</p>

<p><a name="f-request-method"></a><font face="Courier New"><strong>(request-method
request)</strong></font> - reader - a keyword symbol naming the kind of request, typically
:get, :put or :post.</p>

<p><a name="f-request-uri"></a><strong><font face="Courier New">(request-uri request)</font></strong>
- reader - a uri object describing the request.&nbsp;&nbsp; If the request contains a
&quot;Host:&quot; header line then the value of this header is placed in the uri-host and
uri-port slots of this uri object.</p>

<p><a name="f-request-protocol"></a><strong><font face="Courier New">(request-protocol
request)</font></strong> - reader - a keyword symbol naming the http protocol
requested.&nbsp; It is either :http/0.9, :http/1.0 or :http/1.1.</p>

<p><a name="f-request-protocol-string"></a><font face="Courier New"><strong>(request-protocol-string
request) </strong></font>- reader - a string naming the http protocol requested. It is
either &quot;HTTP/0.9&quot;, &quot;HTTP/1.0&quot; or &quot;HTTP/1.1&quot;.</p>

<p><a name="f-request-socket"></a><strong><font face="Courier New">(request-socket
request)</font></strong> - reader - the socket object through which the request was made
and to which the response must be sent.&nbsp;&nbsp;&nbsp; This object can be used to
determine the IP address of the requestor.</p>

<p><a name="f-request-wserver"></a><strong><font face="Courier New">(request-wserver
request)</font></strong> - reader - the wserver object describing the web server taking
this request</p>

<p><a name="f-request-raw-request"></a><strong><font face="Courier New">(request-raw-request
request)</font></strong> - reader -&nbsp; a string holding the exact request made by the
client</p>

<p>&nbsp;</p>

<p><a name="f-request-reply-code"></a><strong><font face="Courier New">(request-reply-code
request)</font></strong> &nbsp;&nbsp;&nbsp;&nbsp; - accessor - the value describes the
response code and string we will return for this request.&nbsp;&nbsp; See the value of the
argument <strong>response</strong> in <strong>with-http-response</strong> for more
information.</p>

<p><a name="f-request-reply-date"></a><strong><font face="Courier New">(request-reply-date
request)</font></strong> &nbsp;&nbsp;&nbsp;&nbsp; - accessor - the date the response will
be made (in Lisp's universal time format).&nbsp; This defaults to the time when the
request arrived.</p>

<p><a name="f-request-reply-headers"></a><strong><font face="Courier New">(request-reply-headers
request)</font></strong> - accessor - an alist of some of the headers to send out with the
reply (other headers values are stored in specific slots of the request object).&nbsp;
Each entry in the alist is a cons where the <strong>car</strong> is a keyword symbol
holding the header name and the <strong>cdr</strong> is the value (it is printed using the
<strong>~a</strong> format directive). &nbsp;&nbsp; Typically <strong>request-reply-headers</strong>
isn't used, instead the headers to be sent are passed as the <strong>:header</strong>
argument to <strong>with-http-body</strong>, or <strong>(setf reply-header-slot-value)</strong>
is called.</p>

<p><a name="f-request-reply-content-length"></a><strong><font face="Courier New">(request-reply-content-length
request) </font></strong>&nbsp;&nbsp;&nbsp; - accessor -&nbsp; the value to send as the
Content-Length of this response.&nbsp;&nbsp; This is computed automatically by
AllegroServe and thus a user program shouldn't have to set this slot under normal
circumstances.</p>

<p><a name="f-request-reply-plist"></a><strong><font face="Courier New">(request-reply-plist
request)</font></strong> &nbsp;&nbsp;&nbsp;&nbsp; - accessor -&nbsp; this slot holds a
property list on which AllegroServe uses to store&nbsp; less important information.&nbsp;
The user program can use it as well.</p>

<p><a name="f-request-reply-strategy"></a><font face="Courier New"><strong>(request-reply-strategy
request)</strong></font>&nbsp;&nbsp; - accessor - the strategy is a list of symbols which
describe how AllegroServe will build a response stream and will send back a
response.&nbsp; More details will be given about the possible strategies at a future time.</p>

<p><a name="f-request-reply-stream"></a><strong><font face="Courier New">(request-reply-stream
request)</font></strong> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - accessor -&nbsp; This is the
stream to be used in user code to send back the body of the response.&nbsp;&nbsp;&nbsp;
This stream must&nbsp; be used instead of the value of <strong>request-socket</strong>.</p>

<p>&nbsp;</p>

<hr>

<h2><a name="cgi-program"></a>CGI Program Execution</h2>

<p>The <a href="http://hoohoo.ncsa.uiuc.edu/cgi/interface.html">Common Gateway Interface</a>
(CGI) specification allows web servers to run programs in response to http requests and to
send the results of&nbsp; the execution of those programs back the web client.
&nbsp;&nbsp; The CGI programs finds information about the request in its environment
variables and, in the case of a <strong>put</strong> or <strong>post</strong> request, the
body of the request is sent to standard input of the program.</p>

<p>CGI is a clumsy and slow protocol for extending the behavior or a web server and is
falling out of favor.&nbsp; However there are legacy CGI applications you may need to call
from AllegroServe.&nbsp;&nbsp; You invoke an external program using the CGI protocol with
the <strong>run-cgi-program</strong> function.</p>

<p><a name="f-run-cgi-program"></a><font face="Courier New"><strong>(run-cgi-program req
ent program &amp;key path-info path-translated<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
script-name query-string <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
auth-type timeout error-output env)</strong></font></p>

<p>In response to an http request, this runs <strong>program</strong> which must be a
string naming an exectuable program or script followed optionally by command line
arguments to pass to that program.&nbsp; Before the <strong>program </strong>is run the
environment variables are set according the the CGI protocol.&nbsp; The <strong>timeout</strong>
argument is how long AllegroServe should wait for a response from the <strong>program </strong>before
giving up.&nbsp;&nbsp; The default is 200 seconds.&nbsp;&nbsp; The <strong>error-output </strong>argument
specifies what should be done with data the cgi program sends to its standard error.
&nbsp; This is described in detail below.&nbsp; The other keyword arguments allow the
caller to specify values for the CGI environment variables that can't be computed
automatically.&nbsp; <strong>path-info</strong> specifies the PATH_INFO environment
variable, and similarly for<strong> path-translated, script-name, query-string</strong>
and <strong>auth-type.</strong>&nbsp;&nbsp; If <strong>query-string</strong> is <em>not</em>
given and the <strong>uri</strong> that invoked this request contains a query part then
that query part is passed in the QUERY_STRING environment variable.&nbsp;&nbsp; If <strong>script-name</strong>
is not given then its value defaults to the path of the uri of the request.&nbsp;&nbsp; If
you wish to add or modify the environment variables set for the cgi process you can
specify a value for <strong>env.&nbsp; </strong>The value of <strong>env</strong> should
be a list of conses, the car of each cons containing the environment variable name (a
string) and the cdr of each cons containing the environment variable value (a
string).&nbsp;&nbsp; <strong>env</strong> is checked after all the standard environment
variables are computed and the value given in <strong>env</strong> will override the value
computed automatically.</p>

<p>cgi programs send their result to standard output (file descriptor 1 on Unix).&nbsp; If
they encounter problems they often send informative messages to standard error (file
descriptor 2 on Unix).&nbsp;&nbsp;&nbsp; The <strong>error-output</strong> argument to
run-cgi-program allows the caller to specify what happens to data sent to standard error.
&nbsp; The possibile values for <strong>error-output</strong> are:</p>

<table border="1" width="100%">
  <tr>
    <td width="32%"><strong>nil</strong></td>
    <td width="68%">The cgi program's standard error is made the same as the Lisp process'
    standard error.&nbsp;&nbsp; This standard error may not be the same as the current binding
    of *standard-error*.</td>
  </tr>
  <tr>
    <td width="32%">pathname or string</td>
    <td width="68%">A file with the given name is opened and standard error is directed to
    that file.</td>
  </tr>
  <tr>
    <td width="32%"><strong>:output</strong></td>
    <td width="68%">Standard error is directed to the same place as standard output thus the
    error messages will be mixed into the result of running the cgi program.</td>
  </tr>
  <tr>
    <td width="32%">symbol or function</td>
    <td width="68%">The function is run whenever there is data available to be read from
    standard error.&nbsp; It must read that data.&nbsp; It must return a true value if it
    detected an end of file during the read and <strong>nil</strong> otherwise. &nbsp;&nbsp;
    The function takes arguments: req ent stream</td>
  </tr>
</table>

<p>A typical way of publishing a CGI page is this:</p>

<pre>(publish :path &quot;/cgi/myprog&quot;
         :function #'(lambda (req ent) 
                        (run-cgi-program req ent &quot;/server/cgi-bin/myprog&quot;)))</pre>

<p>If you're concerned about capturing the error output then here's an example where we
supply&nbsp; a function to collect all the error output into a string. Once collected we
simply print it out here but in a real web server you would want to store it in a log
file.</p>

<pre>(defun cgierr (req ent)
  (let ((error-buffer (make-array 10
                                  :element-type 'character
                                  :adjustable t
                                  :fill-pointer 0)))
    (net.aserve:run-cgi-program
     req ent
     &quot;aserve/examples/cgitest.sh 4&quot;
     :error-output
     #'(lambda (req ent stream)
         (declare (ignore req ent))
         (let (eof)
           (loop
             (let ((ch (read-char-no-hang stream nil :eof)))

               (if* (null ch) then (return))

               (if* (eq :eof ch)
                  then (setq eof t)
                       (return))

               (vector-push-extend ch error-buffer)))
           eof
           )))

    (format t &quot;error buffer is ~s~%&quot; error-buffer)
    ))</pre>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p><strong>Note: </strong>The ability to run CGI programs from AllegroServe was due to
features added in Allegro Common Lisp version 6.1.&nbsp;&nbsp; This will not work in
earlier versions of Allegro CL.</p>

<hr>

<h2><a name="form-processing"></a>Form Processing</h2>

<p>Forms are used on web pages in order to allow the user to send information to the web
server.&nbsp;&nbsp; A form consists of a number of objects, such as text fields, file
fields, check boxes and radio buttons.&nbsp;&nbsp; Each field has a name.&nbsp;&nbsp; When
the user takes a certain action, the form data is encoded and sent to the web server.
&nbsp;&nbsp;&nbsp; There are three ways that data can be sent to the web server.&nbsp; The
method used is determined by the attributes of the <strong>&lt;form&gt;</strong> tag that
defines the form 

<ul>
  <li><strong>&lt;form method=&quot;get&quot;&gt; -&nbsp; </strong>The data is made part of
    the <strong>url</strong> that is sent to the web server and is separated from the url
    itself by a question mark.&nbsp; The AllegroServe url handler code uses <strong>(request-query</strong>
    <strong>req)</strong> to retrieve the alist of form names and values.&nbsp;&nbsp; This
    method has a few disadvantages - the amount of data that can be sent is limited since the
    size of urls is limited.&nbsp; Also the data is visible to everyone seeing the url and
    that may not be desirable.&nbsp; </li>
  <li><strong>&lt;form method=&quot;post&quot;&gt; - </strong>The data is sent in the body of
    the request.&nbsp;&nbsp;&nbsp; The&nbsp; AllegroServe url handler should call <strong>(request-query</strong>
    <strong>req)</strong> to retrieve and decode the data posted.&nbsp;&nbsp;&nbsp; In this
    case&nbsp; <strong>request-query</strong> calls <strong>(get-request-body req)</strong> to
    retrieve the body from the web browser and then <strong>(form-urlencoded-to-query body) </strong>to
    turn it into an alist that associates form field names with values.</li>
  <li><strong>&lt;form method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; - </strong>The
    data is sent in the body of the request in MIME format, with each field in its own
    separate MIME entity.&nbsp;&nbsp;&nbsp; This method is only necessary when one of the
    fields in the form is a <strong>&lt;input type=&quot;file&quot;&gt;</strong> since that
    causes the whole contents of a file to be sent from the browser to the web server. &nbsp;
    When sending a file you would like to include information such as the filename and
    content-type of the file, and by sending it in MIME format there is room for this
    information in the MIME header.&nbsp;&nbsp; We describe how to retrieve data from such a
    form next.</li>
</ul>

<h3>Retrieving multipart/form-data information</h3>

<p>If you create a form with <strong>&lt;form method=&quot;post&quot;
enctype=&quot;multipart/form-data&quot;&gt;</strong> then your url handler must do the
following to retrieve the value of each field in the form: 

<ol>
  <li>Call <strong>(get-multipart-header req)</strong> to return the MIME headers of the next
    field.&nbsp; If this returns nil then there are no more fields to retrieve.&nbsp; You'll
    likely want to call <strong>parse-multipart-header</strong> on the result of <strong>get-multipart-header</strong>
    in order to extract the imporant information from the header.</li>
  <li>Create a buffer and call <strong>(get-multipart-sequence req buffer)</strong> repeatedly
    to return the next chunk of data.&nbsp; When there is no more data to read for this field,
    <strong>get-multipart-sequence</strong> will return nil.&nbsp;&nbsp;&nbsp;&nbsp; If you're
    willing to store the whole multipart data item in a lisp object in memory you can call <strong>get-all-multipart-data</strong>
    instead to return the entire item in one Lisp object.</li>
  <li>go back to step 1</li>
</ol>

<p>It's important to retrieve all of the data sent with the form, even if that data is
just ignored.&nbsp; This is because there may be another http request following this one
and it's important to advance to the beginning of that request so that it is properly
recognized.&nbsp;&nbsp; </p>

<p>Details on the functions are given next.</p>

<p>&nbsp;</p>

<hr>

<p><a name="f-get-multipart-header"></a><strong><font face="Courier New">(get-multipart-header
request)</font></strong></p>

<p>This returns nil or&nbsp; the MIME headers for the next form field in alist form.
&nbsp;&nbsp;&nbsp; If nil is returned then there is no more form data.&nbsp;&nbsp; See <strong>parse-multipart-header</strong>
for a simple way to extratacting information from the header.</p>

<p>For an input field such as <strong>&lt;input type=&quot;text&quot;
name=&quot;textthing&quot;&gt; </strong>the value returned by <strong>get-multipart-header</strong>
would be</p>

<pre>((:content-disposition
      (:param &quot;form-data&quot; (&quot;name&quot; . &quot;textthing&quot;))))</pre>

<p>For an input field such as <strong>&lt;input type=&quot;file&quot;
name=&quot;thefile&quot;&gt; </strong>the value returned by <strong>get-multipart-header</strong>
would be something like</p>

<pre>((:content-disposition
      (:param &quot;form-data&quot; (&quot;name&quot; . &quot;thefile&quot;)
                          (&quot;filename&quot; . &quot;C://down//550mhz.gif&quot;)))
 (:content-type &quot;image/gif&quot;))</pre>

<p>Note that the filename is expressed in the syntax of the operating system on which the
web browser is running.&nbsp; This syntax may or may not make sense to the Lisp pathname
functions of the AllegroServe web server as it may be running on a totally different
operating system.</p>

<p>&nbsp;</p>

<hr>

<p><a name="f-parse-multipart-header"></a><strong><font face="Courier New">(parse-multipart-header
header)</font></strong></p>

<p>This take the value of get-multipart-header and returns values that describe the
important information in the header.</p>

<p>The first value returned is 

<ul>
  <li><strong>:eof</strong>&nbsp; - this header says that there are no more multipart items.
    &nbsp; This value is returned when the value of <strong>header </strong>is <strong>nil.</strong></li>
  <li><strong>:data</strong> - the next multipart item is a simple form value.&nbsp; The
    second value returned is a string naming the value.&nbsp; You can retrieve the value
    itself using repeated calls to <strong>get-multipart-sequence</strong> or one call to <strong>get-all-multipart-data</strong>.
  </li>
  <li><strong>:file </strong>- the next multipart item is a file the user is uploading to the
    server.&nbsp;&nbsp;&nbsp; The second value returned in the name of the form item for which
    this file was given.&nbsp; The third value is the name of the file as specified by the
    user to his browser.&nbsp; The fourth value returned is the MIME Content-Type that the
    browser is guessing applies to this contents of the file.&nbsp;&nbsp; The contents of the
    file can be retrieved using repeated calls to <strong>get-multipart-sequence</strong> or
    one call to <strong>get-all-multipart-data</strong>. </li>
  <li><strong>:nofile</strong> - If a form contains a place for a filename but no filename was
    entered before the form was submitted then this type of header is sent.&nbsp; The values
    returned are the same as those for <strong>:file. </strong>The third value (the filename)
    will always be the empty string. </li>
  <li><strong>nil</strong> - This header has a form not recognized by <strong>parse-multipart-header</strong>.
    &nbsp;&nbsp;&nbsp; If you encounter this please let us know about it since we would like
    enhance <strong>parse-multipart-header</strong> to understand this type of header.
    &nbsp;&nbsp; If you encounter this&nbsp; type of header you still have to read the
    contents of the data item that follows the header in order to read the next header.
    &nbsp;&nbsp; A call to <strong>(get-all-multipart-data req :limit 1000) </strong>will read
    and throw away the following value so you can then read the next header.</li>
</ul>

<hr>

<p><a name="f-get-multipart-sequence"></a><strong><font face="Courier New">(get-multipart-sequence
request buffer &amp;key start end external-format)</font></strong></p>

<p>This retrieves the next chunk of data for the current form field and stores it in <strong>buffer</strong>.
&nbsp;&nbsp; If <strong>start</strong> is given then it specifies the index in the buffer
at which to begin storing the data.&nbsp; If <strong>end</strong> is given then it
specifies the index just after the last index in which to store data.</p>

<p>The return value is <strong>nil </strong>if there is no more data to return, otherwise
it is the index one after the last&nbsp; index filled with data in <strong>buffer.</strong></p>

<p>The buffer can be a one dimensional array of <strong>character</strong> or of <strong>(unsigned-byte
8)</strong>.&nbsp; For the most efficient transfer of data from the browser to
AllegroServe, the program should use a 4096 byte (unsigned-byte 8) array.</p>

<p>If the buffer is&nbsp; a character array then the data is converted from
get-multipart-sequence's (unsigned-byte 8) array to characters using the given<strong>
external-format </strong>(which defaults to<strong> </strong>the value of <strong>*default-aserve-external-format*</strong>)<strong>.</strong></p>

<p><strong>get-multipart-sequence</strong> may return before filling up the whole buffer,
so the program should be sure to make use of the index returned by <strong>get-multipart-sequence</strong>.</p>

<p>&nbsp;</p>

<hr>

<p><a name="f-get-all-multipart-data"></a><font face="Courier New"><strong>(get-all-multipart-data
request &amp;key&nbsp; type size external-format limit)</strong></font></p>

<p>This retrieves the complete data object following the last multipart header.
&nbsp;&nbsp; It returns it as a lisp object.&nbsp;&nbsp; If <strong>type</strong> is<strong>
:text</strong> (the default) then the result is returned as a lisp string.&nbsp;&nbsp; If <strong>type</strong>
is <strong>:binary</strong> then the result is returned as an array of&nbsp; element-type
(unsigned-byte 8).&nbsp;&nbsp;&nbsp; <strong>size </strong>(which defaults to 4096) is the
size of the internal buffers used by this function to retrieve the data.&nbsp;&nbsp; You
usually won't need to specify a value for this but but if you know the values retrieved
are either very small or very large it may may the operation run faster to specify an
appropriate <strong>size</strong>.&nbsp;&nbsp;&nbsp; <strong>external-format</strong> is
used when <strong>type</strong> is <strong>:text</strong> to convert&nbsp; the octet
stream into characters.&nbsp; It defaults to the value of <strong>*default-aserve-external-format*</strong>.
&nbsp; <strong>limit </strong>can be given an integer value that specifies the maximum
size of data you're willing to retrieve.&nbsp; By default there is no limit.&nbsp; This
can be dangerous as a user may try to upload a huge data file which will take up so much
Lisp heap space that it takes down the server.&nbsp;&nbsp; If a <strong>limit</strong> is
given and that limit is reached, <strong>get-all-multipart-data</strong> will continue to
read the data from the client until it reaches the end of the data, however it will <em>not</em>
save it and will return the symbol <strong>:limit</strong> to indicate that the data being
send to the sever exceeded the limit.&nbsp; It will return a second value which is the
size of the data the client tried to upload to the server.&nbsp;&nbsp;&nbsp; If your
application intends to handle very large amounts of data being uploaded to the server you
would be better off using <strong>get-multipart-sequence</strong> since with that you can
write the data buffer by buffer to the disk instead of storing it in the Lisp heap.</p>

<hr>

<p>&nbsp;</p>

<p>In AllegroServe the information sent to the web server as a result of filling out a
form&nbsp; is called a <strong>query</strong>.&nbsp; We store a query as a list of <strong>cons</strong>es,
where the <strong>car</strong> of the <strong>cons </strong>is the name (a string) and the
<strong>cdr</strong> of the cons is the value (another string).&nbsp;&nbsp;&nbsp; When a
query is transmitted by the web browser to AllegroServe it is sent as string using the
encoding <strong>application/x-www-form-urlencoded.&nbsp; </strong>We provide the
following functions to convert between the encoding and the query list:</p>

<p>&nbsp;</p>

<p><a name="f-form-urlencoded-"></a><font face="Courier New"><strong>(form-urlencoded-to-query
string &amp;key external-format)</strong></font></p>

<p>Decodes the string and returns the query list.&nbsp;&nbsp; The default value for <strong>external-format</strong>
is the value of <strong>*default-aserve-external-format*</strong>.</p>

<p>&nbsp;</p>

<p><a name="f-query-to"></a><font face="Courier New"><strong>(query-to-form-urlencoded
query &amp;key external-format)</strong></font></p>

<p>Encodes the query and returns a string.&nbsp;&nbsp; The default value for <strong>external-format</strong>
is the value of <strong>*default-aserve-external-format*.</strong></p>

<p>&nbsp;</p>

<p>Examples:</p>

<pre>user(4): <strong>(query-to-form-urlencoded '((&quot;first name&quot; . &quot;joe&quot;) 
                                     (&quot;last name&quot; . &quot;smith&quot;)))</strong>
&quot;first+name=joe&amp;last+name=smith&quot;

user(5): <strong>(form-urlencoded-to-query &quot;first+name=joe&amp;last+name=smith&quot;)</strong>
((&quot;first name&quot; . &quot;joe&quot;) (&quot;last name&quot; . &quot;smith&quot;))
 </pre>

<pre>user(6): <strong>(query-to-form-urlencoded
            `((&quot;last name&quot; . ,(coerce '(#\hiragana_letter_ta
                                        #\hiragana_letter_na
                                        #\hiragana_letter_ka)
                                      'string)))
              :external-format :euc)</strong>
 &quot;last+name=%a4%bf%a4%ca%a4%ab&quot;</pre>

<pre>user(7): <strong>(query-to-form-urlencoded
            `((&quot;last name&quot; . ,(coerce '(#\hiragana_letter_ta
                                        #\hiragana_letter_na
                                        #\hiragana_letter_ka)
                                      'string)))
             :external-format :shiftjis)</strong>
 &quot;last+name=%82%bd%82%c8%82%a9&quot;

user(8): <strong>(coerce
           (cdr
              (assoc &quot;last name&quot;
                (form-urlencoded-to-query &quot;last+name=%82%bd%82%c8%82%a9&quot;
                                      :external-format :shiftjis)
                :test #'equalp))
           'list)</strong>
 (#\hiragana_letter_ta #\hiragana_letter_na #\hiragana_letter_ka)
</pre>

<hr>

<h2><a name="authorization"></a>Authorization </h2>

<p>You may want to restrict certain entities to be accessible from only certain machines
or people.&nbsp;&nbsp; You can put the test for authorization in the entity response
function using one of the following functions, or you can have the check done
automatically by storing a list of <strong>authorizer</strong> objects in the entity.</p>

<p>&nbsp;</p>

<h3>functions</h3>

<p>These two functions&nbsp; invoke and process the <em>Basic</em> Authorization Method
&nbsp; defined by the http specification.&nbsp;&nbsp;&nbsp; The <strong>password-authorizer</strong>
class described below make use of these functions.</p>

<p><a name="f-get-basic-authorization"></a><strong><font face="Courier New">(get-basic-authorization
request)</font></strong></p>

<p>This function retrieves the Basic authorization information associated with this
request, if any.&nbsp;&nbsp;&nbsp; The two returned values are the name and password, both
strings.&nbsp; If there is no Basic authorization information with this request, <strong>nil</strong>
is returned.</p>

<p>&nbsp;</p>

<p><a name="f-set-basic-authorization"></a><strong><font face="Courier New">(set-basic-authorization
request realm)</font></strong></p>

<p>This adds a header line that requests Basic authorization in the given realm (a
string). &nbsp;&nbsp; This should be called between <strong>with-http-response</strong>
and <strong>with-http-body</strong> and only for response of type 401 (i.e. <strong>*response-unauthorized*</strong>).
&nbsp;&nbsp; The realm is an identifier, unique on this site, for the set of pages for
which access should be authorized by a certain name and password.</p>

<p>&nbsp;</p>

<p>This example manually tests for basic authorization where the name is <strong>foo</strong>
and the password is <strong>bar</strong>.</p>

<pre>(publish :path &quot;/secret&quot;
    :content-type &quot;text/html&quot;
    :function
    #'(lambda (req ent)
        (multiple-value-bind (name password) (<strong>get-basic-authorization</strong> req)
           (if* (and (equal name &quot;foo&quot;) (equal password &quot;bar&quot;))
             then (with-http-response (req ent)
                    (with-http-body (req ent)
                      (html (:head (:title &quot;Secret page&quot;))
                            (:body &quot;You made it to the secret page&quot;))))
             else ; this will cause browser to put up a name/password dialog
                  (with-http-response (req ent :response *response-unauthorized*)
                     (<strong>set-basic-authorization</strong> req &quot;secretserver&quot;)
                     (with-http-body (req ent)))))))

</pre>

<h3>authorizer classes</h3>

<p>The authorizer slot of an entity object can contain a <strong>authorizer</strong>
object or a list of zero or more <strong>authorizer</strong> objects.&nbsp; When a request
arrives for this entity the <strong>authorizer</strong> objects are consulted to see if
this request should be permitted.&nbsp;&nbsp; In order for the request to be permitted, <em>all</em>
authorizer objects must permit the request.&nbsp; AllegroServe supplies three &nbsp;
interesting subclasses of <strong>authorizer</strong> and users are free to add their own
subclasses to support their own authorization needs.&nbsp;&nbsp; </p>

<p>The protocol followed during authorization is this: 

<ol>
  <li>an entity object is selected that matches the request.&nbsp; The value of the entity's
    authorizer slot is retrieved from the entity object.</li>
  <li>if the list of pending authorizer objects is <strong>nil</strong> then it is considered
    authorized.</li>
  <li>otherwise the <strong>authorize</strong> generic function is called on the first <strong>authorizer</strong>
    object, passing <strong>authorize</strong> the <strong>authorizer</strong> object, the
    http-request object and the entity object</li>
  <li>the return value from <strong>authorize </strong>can be&nbsp; <br>
    <strong>t </strong>- meaning this request is authorized to access this entity.&nbsp; In
    this case the first authorizer object is popped from the list of pending authorizer
    objects and we go back to step 2.<br>
    <strong>nil - </strong>meaning that this request isn't authorized.&nbsp; The response from
    AllegroServe will be the standard &quot;failed request&quot; response so the user won't be
    able to distinguish this response from one that would be received if the entity didn't
    exist at all.<br>
    <strong>:deny</strong> - a denied request response will be returned.&nbsp;&nbsp; It will <strong>not</strong>
    use the 401 return code so this will not cause a password box to be displayed by the
    browser.<br>
    <strong>:done</strong> - the request is denied, and a response has already been sent to
    the requestor by the <strong>authorize </strong>function so no further response should be
    made.</li>
</ol>

<p>&nbsp;</p>

<p><a name="c-password-authorizer"></a><strong>password-authorizer</strong>&nbsp; [class]</p>

<p>This subclass of <strong>authorizer</strong> is useful if you want to protect an entity
using the Basic authorization scheme that asks for a name and a password.
&nbsp;&nbsp;&nbsp; When you create this class of object you should supply values for the
two slots:</p>

<table border="1" width="100%">
  <tr>
    <td width="13%"><big><strong>Slot Name</strong></big></td>
    <td width="11%"><big><strong>initarg</strong></big></td>
    <td width="76%"><big><strong>what</strong></big></td>
  </tr>
  <tr>
    <td width="13%"><strong>allowed</strong></td>
    <td width="11%">:<strong>allowed</strong></td>
    <td width="76%">list of conses, each cons having the form <strong>(&quot;name&quot; .
    &quot;password&quot;) </strong>where any of the listed name password pairs will allow
    access to this page.</td>
  </tr>
  <tr>
    <td width="13%"><strong>realm</strong></td>
    <td width="11%"><strong>:realm</strong></td>
    <td width="76%">A string which names the protection space for the given name and password.
    &nbsp; The realm will appear in the dialog box the browser displays when asking for a name
    and password. </td>
  </tr>
</table>

<p>An example of it's use is the following where we allow access only if the user enters a
name of <strong>joe</strong> and a password of <strong>eoj</strong> or a name of <strong>fred</strong>
and a password of<strong> derf</strong>.</p>

<pre>  (publish :path &quot;/foo&quot;
    :content-type &quot;text/html&quot;
    :authorizer (make-instance 'password-authorizer
                       :allowed '((&quot;joe&quot; . &quot;eoj&quot;)
                                  (&quot;fred&quot; . &quot;derf&quot;))
                       :realm &quot;SecretAuth&quot;)

    :function
    #'(lambda (req ent)
        (with-http-response (req ent)
           (with-http-body (req ent)
              (html (:head (:title &quot;Secret page&quot;))
                    (:body &quot;You made it to the secret page&quot;))))))</pre>

<p>&nbsp;</p>

<p><a name="c-location-authorizer"></a><strong>location-authorizer</strong> [class]</p>

<p>This authorizer class checks the IP address of the request to see if it is permitted
access to the entity.&nbsp; The&nbsp; authorizer can specify a sequence of&nbsp; patterns
and for each pattern a command of <strong>:accept </strong>(permit the access) or <strong>:deny</strong>
(forbid the access).&nbsp;&nbsp;&nbsp; The first pattern that matches determines if the
request is accepted or denied.&nbsp; If the pattern list is empty or if no pattern
matches, then the request is accepted.&nbsp; </p>

<p>The single slot of an object of class <strong>location-authorizer</strong> is</p>

<table border="1" width="100%">
  <tr>
    <td width="13%"><big><strong>Slot Name</strong></big></td>
    <td width="11%"><big><strong>initarg</strong></big></td>
    <td width="76%"><big><strong>what</strong></big></td>
  </tr>
  <tr>
    <td width="13%"><strong>patterns</strong></td>
    <td width="11%">:<strong>patterns</strong></td>
    <td width="76%">a list of patterns and commands, where the syntax of a pattern-command is
    described below.</td>
  </tr>
</table>

<p>A pattern can be 

<ul>
  <li><strong>:accept</strong> -- this is a pattern that matches all IP addresses and causes
    the access to be authorized</li>
  <li><strong>:deny</strong> -- this is a pattern that matches all IP addresses and causes the
    access to be rejected</li>
  <li><strong>(:accept ipaddress [bits])</strong> --&nbsp; if the request's IP address matches
    the most significant <strong>bits</strong> of <strong>ipaddress</strong> then this access
    is accepted.&nbsp;&nbsp; <strong>bits</strong> is optional and defaults to 32 (the whole
    address).&nbsp; The ipaddress can be an integer (the 32 bit IP address) or it can be a
    string in either dotted form &quot;123.23.43.12&quot;&nbsp; or a host name
    &quot;foo.bar.com&quot;.&nbsp;&nbsp; In the case of a host name, a lookup must be done to
    map the host name to an&nbsp; IP address.&nbsp;&nbsp; If this lookup fails then it is
    assumed that the pattern doesn't match.&nbsp;&nbsp; If <strong>ipaddress</strong> is a
    string, then the first time it is examined during authorization it is converted to an
    integer IP address and that value replaces the string in the pattern (thus caching the
    result of the conversion to an IP address).</li>
  <li><strong>(:deny ipaddress [bits])</strong> -- just like the case above except the request
    is rejected if it matches the <strong>ipaddress</strong>.&nbsp;&nbsp; One difference is
    this: if the <strong>ipaddress </strong>is a host name and that host name cannot be
    translated to an IP address, then it is assumed to match, and thus the request will be
    denied.&nbsp; </li>
</ul>

<p>The example of using a <strong>location-authorizer</strong> only permits connections
coming in via the loopback network (which occurs if you specify <a
href="http://localhost/whatever">http://localhost/whatever</a>) or if they come from one
particular machine (tiger.franz.com).&nbsp; Note that we end the pattern list with <strong>:deny</strong>
so that anything not matching the preceding patterns will be denied.</p>

<pre>(publish :path &quot;/local-secret-auth&quot;
    :content-type &quot;text/html&quot;
    :authorizer (make-instance 'location-authorizer
                         :patterns '((:accept &quot;127.0&quot; 8)
                                     (:accept &quot;tiger.franz.com&quot;)
                                     :deny))

    :function
    #'(lambda (req ent)
        (with-http-response (req ent)
           (with-http-body (req ent)
               (html (:head (:title &quot;Secret page&quot;))
                     (:body (:b &quot;Congratulations. &quot;)
                       &quot;You made it to the secret page&quot;))))))

</pre>

<p><strong><a name="c-function-authorizer"></a>function-authorizer </strong>&nbsp; [class]</p>

<p>This authorizer contains a function provided by the user which is used to test if the
request is authorized.&nbsp;&nbsp; The function take three arguments, the http-request
object, the entity and the authorizer object.&nbsp;&nbsp; It must return one of the four
value that the <strong>authorize</strong> function returns, namely <strong>t, nil :deny</strong>
or <strong>:done.</strong></p>

<p>A function-authorizer is created as follows</p>

<pre>(make-instance 'function-authorizer
    :function #'(lambda (req ent auth)
                          t  ; always authorize
                 ))</pre>

<p>The function slot can be set using (setf function-authorizer-function) if you wish to
change it after the authorizer has been created.</p>

<p>&nbsp;</p>

<h2><a name="cookies"></a>Cookies</h2>

<p>Cookies are name value pairs that a web server can direct a web browser to save and
then pass back to the web server under certain circumstances.&nbsp;&nbsp; Some users
configure their web browsers to reject cookies, thus you are advised against building a
site that depends on cookies to work.</p>

<p>Each cookie has these components: 

<ol>
  <li><strong>name</strong> - a string.&nbsp;&nbsp; Since you can get multiple cookies sent to
    you by a web browser, using a unique name will allow you to distinguish the values.</li>
  <li><strong>value</strong> - a string</li>
  <li><strong>path</strong> - a string which must be the prefix of the request from the web
    browser for this cookie to be sent.&nbsp; The string &quot;/&quot; is the prefix of all
    requests.</li>
  <li><strong>domain </strong>- a string which must be the suffix of the name of the machine
    where the request is being sent in order for this cookie to be sent.</li>
  <li><strong>expiration</strong> - a time when this cookie expires. </li>
  <li><strong>secure</strong> - either true or false.&nbsp; If true then this cookie will only
    be sent if the connection is through a secure socket</li>
</ol>

<p>&nbsp;</p>

<p><a name="f-set-cookie-header"></a><strong><font face="Courier New">(set-cookie-header
request &amp;key name value expires domain path secure encode-value external-format)</font></strong></p>

<p>This function should be called between the calls to <strong>with-http-response </strong>and
<strong>with-http-body</strong>.&nbsp;&nbsp; It can be called more than once.&nbsp; Each
call will cause one Set-Cookie directive to be sent to the web browser. &nbsp;&nbsp;&nbsp;
The <strong>name</strong> and <strong>value</strong> arguments should be given (and they
should be strings).&nbsp; They will be automatically encoded using the same encoding used
in urls (we call it <em>uriencoding). </em>The purpose of this encoding is to convert
characters that are either unprintable or those that have a special meaning into a
printable string.&nbsp;&nbsp;&nbsp; The web browser doesn't care about the <strong>name</strong>
and <strong>value</strong>, it just stores them and sends them back to the web server.
&nbsp;&nbsp;&nbsp; If you use the <strong>get-cookie-values </strong>function to retrieve
the cookie <strong>name</strong> and <strong>value</strong> pairs, then it will
automatically decode the uriencoding.</p>

<p>You can disable the encoding of the value by specifying a <strong>nil</strong> value to
<strong>encode-value</strong>.&nbsp;&nbsp;&nbsp; This should only be necessary if you are
working with buggy http client applications.<br>
<br>
If the <strong>path </strong>argument isn't given, it will default to &quot;/&quot; which
will allow this cookie to match all requests.<br>
If the <strong>domain</strong> argument isn't given then it will default to the host to
which this request was sent.&nbsp; If you wish to specify this you are only allowed to
specify a subsequence of the host to which this request was sent (i.e the name of the
machine running the webserver).&nbsp;&nbsp; The <strong>domain</strong> should have at
least two periods in it (i.e.&nbsp; &quot;.foo.com&quot;).<br>
<strong>expires</strong> can be a lisp universal time or it can be the symbol <strong>:never</strong>
meaning this should never expire.&nbsp; If <strong>expires </strong>isn't given or is <strong>nil</strong>
then this cookie will expire when the user quits their web browser.<br>
<strong>secure</strong> should be true or false.&nbsp; Any non-nil value is interpreted as
true. The default value is false.<br>
The <strong>external-format</strong> is used to convert bytes to characters. &nbsp; It
defaults to the value of <strong>*default-aserve-external-format*</strong>. </p>

<p>&nbsp;</p>

<p><a name="f-get-cookie-values"></a><strong><font face="Courier New">(get-cookie-values
request &amp;key external-format)</font></strong></p>

<p>Return the cookie <strong>name</strong> and <strong>value</strong> pairs from the
header of the request.&nbsp;&nbsp; Each <strong>name</strong> <strong>value</strong> pair
will be in a cons whose <strong>car</strong> is the <strong>name</strong> and whose <strong>cdr</strong>
is the <strong>value</strong>.&nbsp;&nbsp; The names and values will be decoded (in other
words the decoding done by <strong>set-cookie-header</strong> will be undone).
&nbsp;&nbsp; The <strong>external-format</strong> is used to convert bytes to characters.
&nbsp; It defaults to the value of <strong>*default-aserve-external-format*</strong>. </p>

<p>&nbsp;</p>

<hr>

<h2><a name="varaibles"></a>Variables</h2>

<p>These special variables contain&nbsp; information about AllegroServe or help control
AllegroServe:</p>

<p><a name="v-aserve-version"></a><strong><font face="Courier New">*aserve-version*</font></strong>
- a list of three values: (major-version minor-version sub-minor-version) which is usually
printed with periods separating the values (i.e. X.Y.Z).</p>

<p><a name="v-default-aserve-external-format"></a><strong><font face="Courier New">*default-aserve-external-format*</font></strong>
- a symbol or external format object which is the default value for those AllegroServe
functions that take an external-format argument.&nbsp;&nbsp; http requests are normally
run in separate lisp threads and those threads bind *default-aserve-external-format* to
the value of the external-format argument to the start function.&nbsp;&nbsp; Thus changing
the value of *default-aserve-external-format* in one thread will not affect its value in
other threads.&nbsp;&nbsp; You should decide the default external format before you start
AllegroServe running.</p>

<p><a name="v-http-response-timeout"></a><strong><font face="Courier New">*http-response-timeout*</font></strong>
- the default value for the timeout argument to with-http-response.&nbsp;&nbsp; [in future
versions of AllegroServe we'll treat this value like *default-aserve-external-format* and
bind it in each worker thread]</p>

<p><a name="v-mime-types"></a><strong><font face="Courier New">*mime-types*</font></strong>
- a hash table where the keys are the file types (e.g. &quot;jpg&quot;) and the values are
the MIME types (e.g. &quot;image/jpeg&quot;).</p>

<p>&nbsp;</p>

<hr>

<h2><a name="iseve-request-proc"></a>AllegroServe request processing protocol</h2>

<p>We'll describe here the steps AllegroServe goes through from the time it receives a
request until a response to that request has been sent back to the
browser.&nbsp;&nbsp;&nbsp; We want the protocol to be open so that users can extend
AllegroServe's behavior to suit their needs.&nbsp; However given that AllegroServe is a
new program and will be undergoing extensive review from its users, we expect that the
protocol will change.&nbsp;&nbsp; It shouldn't lose any of its current extensibility but
the names and argument lists of generic functions may change.&nbsp; </p>

<p>When a client connects to the port on which AllegroServe is listening, AllegroServe
passes that connected socket to a free worker thread which then wakes up and calls the
internal function <strong>net.aserve::process-connection</strong>.&nbsp;&nbsp; If there
are no free worker threads then AllegroServe waits for one to be available.</p>

<p>In each worker thread the variable <strong>*wserver*</strong> is bound to the <strong>wserver</strong>
object that holds all the information about the webserver on which the connection was made
(remember that one AllegroServe process can be running more than one
webserver).&nbsp;&nbsp; <strong>process-connection</strong> reads the request from the
socket (but doesn't read past the header lines). &nbsp;&nbsp;&nbsp; If the request can't
be read within <strong>*read-request-timeout* </strong>seconds (currently 20) then the
request is rejected.&nbsp;&nbsp;&nbsp; The request is stored in an object of class <strong>http-request</strong>.&nbsp;&nbsp;&nbsp;
Next <strong>process-connection</strong> calls <strong>handle-request</strong> to do all
the work of the request and then <strong>log-request</strong> to log the action of the
request.&nbsp; Finally if the response to the request indicated that the connection was to
be kept open rather than being closed after the response, then <strong>process-connection</strong>
loops back to the top to read the next request.</p>

<p>&nbsp;</p>

<p><a name="f-handle-request"></a><strong><font face="Courier New">(handle-request (req
http-request))</font></strong> &nbsp;&nbsp; [generic function]</p>

<p>This generic function must locate the entity to handle this request and then cause it
to respond to the request.&nbsp;&nbsp; If there is no matching entity then <strong>handle-request</strong>
must send a response back to the client itself.&nbsp; <strong>handle-request</strong> uses
locators to find the entity (more on this below), and then if an entity is found and that
entity has an authorizer, it calls <strong>authorize</strong> to see if this request is
allowed to access the selected entity.&nbsp; If the entity passes the authorization then <strong>process-entity</strong>
is called to cause the entity to respond to the request.&nbsp; <strong>process-entity</strong>
returns true if it processed the entity, and nil if did not in which case the search
continues for an entity.&nbsp; If there is no entity to respond then <strong>failed-request</strong>
is called to send back a failure message.</p>

<p>A <strong>locator</strong> is an object used to map requests into entities.
&nbsp;&nbsp; The value of <strong>(wserver-locators *wserver*)</strong> is a list of
locator objects.&nbsp;&nbsp; <strong>handle-request</strong> calls </p>

<p><a name="f-standard-locator"></a><strong><font face="Courier New">(standard-locator
(req http-request) (loc locator)) </font></strong>[generic function]</p>

<p>on each successive locator in that list until one returns an entity object.
&nbsp;&nbsp;&nbsp; AllegroServe has two built-in locator classes, <strong>locator-exact</strong>
and <strong>locator-prefix</strong>, that are subclasses of <strong>locator.&nbsp;&nbsp; </strong>When
you call <strong>publish</strong> or <strong>publish-file</strong> you are adding the
entity to locator of class <strong>locator-exact</strong> found in the <strong>wserver-locators
</strong>list.&nbsp;&nbsp; When you call <strong>publish-directory</strong> you are adding
to the locator of class <strong>locator-prefix.</strong>&nbsp;&nbsp;&nbsp; Users are free
to define new locator classes.&nbsp;&nbsp;&nbsp; Locators should define the <strong>standard-locator</strong>
method as well as </p>

<p><a name="f-unpublish-locator"></a><strong><font face="Courier New">(unpublish-locator
(loc locator))</font></strong> &nbsp;&nbsp; [generic&nbsp; function]</p>

<p>which if called should remove all published entities from the locator.</p>

<p>&nbsp;</p>

<p>Let's return to <strong>handle-request.</strong>&nbsp; It has called <strong>standard-locator</strong>
and found an entity.&nbsp;&nbsp; Next it checks to see if the entity has an authorizer
value and if so calls</p>

<p><a name="f-authorize"></a><strong><font face="Courier New">(authorize (auth authorizer)
(req http-request) (ent entity)) </font></strong>&nbsp; [generic function]</p>

<p>The return value will be one of 

<ul>
  <li><strong>t -- </strong>The request is authorized,&nbsp; call <strong>process-entity</strong>
    to make the entity respond.</li>
  <li><strong>nil</strong> -- The request is not authorized, call <strong>failed-request </strong>to
    send back a response.</li>
  <li><strong>:deny</strong> -- The request is denied and we want the user to know that it was
    denied rather than sending a generic failed message, call <strong>denied-request</strong>
    to send back a response.</li>
  <li><strong>:done</strong> -- The <strong>authorize</strong> function has sent back a
    response, there is nothing more for <strong>handle-request</strong> to do for this
    request.</li>
</ul>

<p>If there is no authorizer for this entity then we just call <strong>process-entity.</strong>
&nbsp;&nbsp; If there is no entity, then we call <strong>failed-request</strong>. </p>

<p>&nbsp;</p>

<p><a name="f-failed-request"></a><strong><font face="Courier New">(failed-request (req
http-request))</font></strong> &nbsp;&nbsp; [generic function]</p>

<p>send back a response to the effect that the url request doesn't exist on this server.</p>

<p>&nbsp;</p>

<p><a name="f-denied-request"></a><strong><font face="Courier New">(denied-request (req
http-request))</font></strong> &nbsp; [generic function]</p>

<p>send back a response to the effect that access to the requested url was denied. </p>

<p>&nbsp;</p>

<p><a name="f-process-entity"></a><strong><font face="Courier New">(process-entity&nbsp;
(req http-request) (ent entity))</font></strong> &nbsp;&nbsp; [generic function]</p>

<p>Send back a response appropriate to the given entity.&nbsp;&nbsp;&nbsp;&nbsp; The
macros with-http-response and with-http-body should be used in the code that sends the
response.</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<hr>

<h2><a name="cliient-request"></a>Client functions</h2>

<p>AllegroServe has a set of functions that perform http client-side actions.&nbsp;&nbsp;
These functions are useful in generating computed pages that reflect the contents of other
pages.&nbsp; We also use the client-side http functions to test AllegroServe.</p>

<p>The client-side functions described in this section are exported from the<font
face="Courier New"> net.aserve.client</font> package.</p>

<p>The function <strong>do-http-request </strong>sends a request and retrieves the whole
response.&nbsp;&nbsp;&nbsp; This is the most convenient function to use to retrieve a web
page.</p>

<p>If you need more control over the process you can use the functions: <strong>make-http-request</strong>,
<strong>read-client-response-headers </strong>and <strong>client-request-read-sequence</strong>.</p>

<p>&nbsp;</p>

<p><a name="f-do-http-request"></a><strong><font face="Courier New">(do-http-request uri
&amp;key method protocol accept <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
content content-type query format cookies <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
redirect redirect-methods basic-authorization<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
keep-alive headers proxy user-agent external-format ssl<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
skip-body)</font></strong></p>

<p>Sends a request to <strong>uri</strong> and returns four values: 

<ol>
  <li>The body of the response.&nbsp; If there is no body the empty string is returned.</li>
  <li>the response code (for example, 200, meaning that the request succeeded)</li>
  <li>an alist of headers where the <strong>car</strong> of each entry is a lowercase string
    with the header name and the <strong>cdr</strong> is a string with the value of that
    header item.</li>
  <li>the uri object denoting the page accessed.&nbsp; This is normally computed from the <strong>uri</strong>
    value passed in but if redirection was done then this reflects the target of the
    redirection.&nbsp; If you plan to interpret relative html links in the <strong>body</strong>
    returned then you must do so with respect to <em>this</em> uri value </li>
</ol>

<p>The <strong>uri</strong> can be a uri object or a string.&nbsp;&nbsp; The scheme of the
<strong>uri</strong> must be nil or &quot;http&quot;.&nbsp;&nbsp; The keyword arguments to
<strong>do-http-request </strong>are</p>

<table border="1" width="100%">
  <tr>
    <th width="22%">Name</th>
    <th width="16%">default</th>
    <th width="62%">description</th>
  </tr>
  <tr>
    <td width="22%">method</td>
    <td width="16%">:get</td>
    <td width="62%">The type of request to make.&nbsp; Other possible values are <strong>:put</strong>,
    <strong>:post</strong> and<strong> :head</strong>.&nbsp; <strong>:head</strong> is useful
    if you just want to see if the link works without downloading the data.</td>
  </tr>
  <tr>
    <td width="22%">protocol</td>
    <td width="16%">:http/1.1</td>
    <td width="62%">The other possible value is <strong>:http/1.0</strong>.&nbsp; Modern web
    servers will return the response body in chunks if told to use the <strong>:http/1.1</strong>
    protocol.&nbsp; Buggy web servers may do chunking incorrectly (even Apache has bugs in
    this regard but we've worked around them).&nbsp; If you have trouble talking to a web
    server you should try specifying the <strong>:http/1.0</strong> protocol to see if that
    works.</td>
  </tr>
  <tr>
    <td width="22%">accept</td>
    <td width="16%">&quot;*/*&quot;</td>
    <td width="62%">A string listing of MIME types that are acceptable as a response to this
    request.&nbsp; The type listed can be simple such as &quot;text/html&quot; or more complex
    like &quot;text/html, audio/*&quot;&nbsp; The default is to accept anything which is
    expressed &quot;*/*&quot;.</td>
  </tr>
  <tr>
    <td width="22%">content</td>
    <td width="16%">nil</td>
    <td width="62%">If the method is <strong>:put</strong> or<strong> :post</strong> then the
    request should include something to be sent to the web server.&nbsp;&nbsp; The value of
    this argument is either a string or a vector of type (unsigned-byte 8) which will be sent
    to the web server.&nbsp;&nbsp; It may also be a list of strings or vectors. See the <strong>query</strong>
    argument for a more convenient way to <strong>:post</strong> data to a form.</td>
  </tr>
  <tr>
    <td width="22%">content-type</td>
    <td width="16%">nil</td>
    <td width="62%">A string which is to be the value of the Content-Type header field,
    describing the format of the value of the <strong>content</strong> argument. &nbsp;&nbsp;
    This is only needed for <strong>:put</strong> and <strong>:post</strong> requests.</td>
  </tr>
  <tr>
    <td width="22%">query</td>
    <td width="16%">nil</td>
    <td width="62%">This is a query alist of the form suitable for <strong>query-to-form-urlencoded</strong>.
    &nbsp; If the method is a <strong>:get</strong> then the value of&nbsp; this argument is <strong>urlencoded</strong>
    and made the query string of the uri being accessed.&nbsp; If the method is <strong>:post</strong>
    then the query string is <strong>urlencoded</strong> and made the <strong>content</strong>
    of the request.&nbsp; Also the <strong>content-type</strong> is set to <strong>application/x-www-form-urlencoded.</strong>
    </td>
  </tr>
  <tr>
    <td width="22%">format</td>
    <td width="16%">:text</td>
    <td width="62%">The body of the response is returned as a string if the value is<strong>
    :text </strong>or as an array of type (unsigned-byte 8) if the value is <strong>:binary</strong>.
    &nbsp;&nbsp; When the body is a string the external-format argument is important.</td>
  </tr>
  <tr>
    <td width="22%">cookies</td>
    <td width="16%">nil</td>
    <td width="62%">If you wish the request to include applicable cookies and for returned
    cookies to be saved, then a <strong>cookie-jar</strong> object should be passed as the
    value of this argument.</td>
  </tr>
  <tr>
    <td width="22%">redirect</td>
    <td width="16%">5</td>
    <td width="62%">If the response is a redirect (code 301, 302, 303), and the method is one
    given by the value of <strong>redirect-methods </strong>then if this argument is true
    (and, if an integer, positive), <strong>do-http-request</strong> will call itself to
    access the page to which the redirection is pointed.&nbsp; If <strong>redirect</strong> is
    an integer then in the recursive call the value passed for <strong>redirect</strong> will
    be one less than the current value.&nbsp; This prevents infinite recursion due to
    redirection loops.</td>
  </tr>
  <tr>
    <td width="22%">redirect-methods</td>
    <td width="16%">(:get :head)</td>
    <td width="62%">List of http methods which will be redirected if <strong>redirect</strong>
    is true.</td>
  </tr>
  <tr>
    <td width="22%">basic-authorization</td>
    <td width="16%">nil</td>
    <td width="62%">If given, it is a cons whose <strong>car</strong> is the name and whose <strong>cdr
    </strong>is the password to be used to get authorization to access this page.</td>
  </tr>
  <tr>
    <td width="22%">keep-alive</td>
    <td width="16%">nil</td>
    <td width="62%">If true then the web server will be told to keep the connection alive.
    &nbsp;&nbsp; Since <strong>do-http-request</strong> closes the connection after the
    request this option currently does no more than allow us to experiment with how a web
    server responds to a keep-alive request.</td>
  </tr>
  <tr>
    <td width="22%">headers</td>
    <td width="16%">nil</td>
    <td width="62%">an alist of conses <font face="Courier New">(&quot;header-name&quot; .
    &quot;header-value&quot;)</font> for additional headers to send with the request.</td>
  </tr>
  <tr>
    <td width="22%">proxy</td>
    <td width="16%">nil</td>
    <td width="62%">the name and optionally the port number of a proxying web server through
    which this request should be made.&nbsp;&nbsp; The form is of the argument is <a
    href="http://www.machine.com">&quot;www.machine.com&quot;</a> or <a
    href="http://www.machine.com:8000">&quot;www.machine.com:8000&quot;</a> if the web server
    is listening on port 8000 rather than 80.&nbsp;&nbsp; Proxying web servers are often used
    when clients are behind firewalls that prevent direct access to the internet. &nbsp;
    Another use is to centralize the page cache for a group of clients.</td>
  </tr>
  <tr>
    <td width="22%">user-agent</td>
    <td width="16%">nil</td>
    <td width="62%">If given it specifies the value of the User-Agent header to be sent with
    the request.&nbsp; Some sites respond differently based on the user-agent they believe has
    made the request.&nbsp; The lack of a User-Agent header may cause a server to ignore a
    request since it believes that it is being probed by a robot.&nbsp; The value of
    user-agent can be a string or one of the keywords <strong>:aserve</strong>, <strong>:netscape</strong>
    or <strong>:ie</strong> in which case an appropriate user agent string is sent.</td>
  </tr>
  <tr>
    <td width="22%">external-format</td>
    <td width="16%">the value of <strong>*default-aserve-external-format*</strong></td>
    <td width="62%">This determines the socket stream's external format.</td>
  </tr>
  <tr>
    <td width="22%">ssl</td>
    <td width="16%">nil</td>
    <td width="62%">If true then the connection is made using the Secure Sockets Layer
    protocol.&nbsp;&nbsp;&nbsp; If the uri uses the <strong>https</strong> scheme then <strong>ssl</strong>
    is assumed to be true and the <strong>ssl </strong>argument need not be specified.</td>
  </tr>
  <tr>
    <td width="22%">skip-body</td>
    <td width="16%">nil</td>
    <td width="62%">If the value is a fucntion (satisifies <strong>functionp</strong>) then
    the value is funcalled passing the <strong>client-request </strong>object as an argument.
    &nbsp; At this point the client-request object contains the information on the headers of
    the response.&nbsp;&nbsp; The function should return true if the body of the response
    should be skipped and <strong>nil</strong> returned as the first value from
    do-http-request.&nbsp; If skip-body is not a function then if its value is true then
    reading the body is skipped and <strong>nil</strong> returned in its place.</td>
  </tr>
</table>

<p>&nbsp;</p>

<p>For example:</p>

<pre>user(5): <strong>(do-http-request &quot;http://www.franz.com&quot;)</strong>
</pre>

<pre>&quot;&lt;HTML&gt;
    &lt;HEAD&gt;
        &lt;TITLE&gt;Franz Inc: Allegro Common Lisp and Common Lisp Products&lt;/TITLE&gt;
        &lt;BASE FONTFACE=\&quot;helvetica, arial\&quot; FONTSIZE=\&quot;1\&quot;&gt;
.....</pre>

<pre>&quot;
200
((&quot;content-type&quot; . &quot;text/html&quot;) (&quot;transfer-encoding&quot; . &quot;chunked&quot;)
(&quot;server&quot; . &quot;Apache/1.3.9 (Unix) PHP/3.0.14&quot;)
(&quot;date&quot; . &quot;Mon, 24 Apr 2000 11:00:51 GMT&quot;))
</pre>

<p>&nbsp;</p>

<p>It's easy to use <strong>do-http-request</strong> to fill in form objects on a page.
&nbsp; If the form has input elements named&nbsp; <strong>width</strong> and <strong>height</strong>
then you can send a request that specifies that information in this way:</p>

<pre><font face="Courier New">(do-http-request <a href="http://www.foo.com/myform.html">&quot;http://www.foo.com/myform.html&quot;</a> 
                 :query '((&quot;width&quot; . 23) (&quot;height&quot; . 45)))</font></pre>

<p>The above assumes that the method on the form is &quot;GET&quot;.&nbsp;&nbsp; If the
method is &quot;POST&quot; then a similar call will work:</p>

<pre><font face="Courier New">(do-http-request <a href="http://www.foo.com/myform.html">&quot;http://www.foo.com/myform.html&quot;</a>  <strong>:method :post</strong>
                 :query '((&quot;width&quot; . 23) (&quot;height&quot; . 45)))</font></pre>

<p><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </p>

<p>&nbsp;</p>

<p>Before we describe the lower level client request functions we will describe two
classes of objects used in that interface.</p>

<h2><a name="c-client-request"></a>client-request</h2>

<p>A <strong>client-request</strong> object includes the information about the request and
the response.</p>

<p>The public fields of a <strong>client-request</strong> that are filled in after a call
to <strong>make-http-client-request</strong> are:</p>

<table border="1" width="100%">
  <tr>
    <th width="31%">Accessor</th>
    <th width="69%">Description</th>
  </tr>
  <tr>
    <td width="31%">client-request-uri</td>
    <td width="69%">uri object corresponding to this request</td>
  </tr>
  <tr>
    <td width="31%">client-request-socket</td>
    <td width="69%">socket object open to the web server denoted by the uri</td>
  </tr>
  <tr>
    <td width="31%">client-request-cookies</td>
    <td width="69%">the cookie-jar object (if any) passed in with this request.</td>
  </tr>
</table>

<p>&nbsp;</p>

<p>After <strong>read-client-response-headers</strong> is called, the following fields of
the <strong>client-request</strong> objects are set:</p>

<table border="1" width="100%">
  <tr>
    <th width="39%">Accessor</th>
    <th width="61%">Description</th>
  </tr>
  <tr>
    <td width="39%">client-request-response-code</td>
    <td width="61%">the integer that is the response code for this request.&nbsp; The most
    common codes are 200 for Success and 404 for Not Found.</td>
  </tr>
  <tr>
    <td width="39%">client-request-headers</td>
    <td width="61%">an alist of header values in the response.&nbsp; Each entry is a cons of
    the form <font face="Courier New">(&quot;header-name&quot; . &quot;header-value&quot;)</font>.
    &nbsp; The header names are all lower case.</td>
  </tr>
  <tr>
    <td width="39%">client-request-protocol</td>
    <td width="61%">A keyword symbol naming the protocol&nbsp; that the web server returned
    (which may be different that the protocol given in the request).&nbsp;&nbsp; A typical
    return value is <strong>:http/1.1</strong></td>
  </tr>
  <tr>
    <td width="39%">client-request-response-comment</td>
    <td width="61%">A string giving a textual version of the response code.&nbsp;&nbsp; The
    string is arbitrary and you should not depend on all web servers returning the same string
    for any given response code.</td>
  </tr>
</table>

<p>&nbsp;</p>

<h2><a name="c-cookie-jar"></a>cookie-jar</h2>

<p>A <strong>cookie-jar</strong> is a respository for cookies.&nbsp; Cookies are stored in
a jar when a response from a client request includes <font face="Courier New">Set-Cookie</font>
headers.&nbsp;&nbsp; Cookies from a jar are sent along with a request when they are
applicable to the given request.&nbsp;&nbsp; We won't describe the rules for cookie
applicability here, you need only know that if you use our client functions &nbsp;to
access a site that uses cookies to implement persistence, then you should create a <strong>cookie-jar</strong>
object and pass that same object in with each request.&nbsp;&nbsp; More information on
cookies can be found <a
href="http://developer.netscape.com:80/docs/manuals/js/client/jsref/cookies.htm">here</a>.</p>

<p>A <strong>cookie-jar</strong> is created with <font face="Courier New">(make-instance
'cookie-jar).</font></p>

<p>&nbsp;</p>

<p><strong><font face="Courier New">(cookie-jar-items&nbsp; cookie-jar)</font></strong></p>

<p>returns an alist of the cookies in the jar where each item has the form:</p>

<p><strong>(hostname cookie-item ...)</strong></p>

<p>The <strong>hostname</strong> is a string which is matched against the suffix of the
name of the host in the request (that is, a hostname of&nbsp; <font face="Courier New">&quot;.foo.com&quot;</font>
matches <font face="Courier New">&quot;a.foo.com&quot;</font> and <font face="Courier New">&quot;b.foo.com&quot;</font>.
).&nbsp;&nbsp;&nbsp; The hostname should have at least two periods in it.
&nbsp;&nbsp;&nbsp; The following <strong>cookie-item</strong> objects in the list all
apply to that hostname. &nbsp;&nbsp; A <strong>cookie-item</strong> is a defstruct object
and has these fields</p>

<table border="1" width="100%">
  <tr>
    <th width="29%">Accessor</th>
    <th width="71%">Description</th>
  </tr>
  <tr>
    <td width="29%">cookie-item-path</td>
    <td width="71%">A string that must be the prefix of the path of the request for it to
    match.&nbsp; The prefix &quot;/&quot; matches all paths.</td>
  </tr>
  <tr>
    <td width="29%">cookie-item-name</td>
    <td width="71%">The name of the cookie.&nbsp; A string.</td>
  </tr>
  <tr>
    <td width="29%">cookie-item-value</td>
    <td width="71%">The value of the cookie.&nbsp; A string.</td>
  </tr>
  <tr>
    <td width="29%">cookie-item-expires</td>
    <td width="71%">A string holding the time the cookie expires [in a future release we may
    make this a universal time]</td>
  </tr>
  <tr>
    <td width="29%">cookie-item-secure</td>
    <td width="71%">true if this cookie should only be sent over a secure connection.</td>
  </tr>
</table>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p><a name="f-make-http-client-request"></a><strong><font face="Courier New">(make-http-client-request
uri &amp;key method protocol keep-alive<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
accept cookies headers proxy<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
basic-authorization query<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
content content-type content-length<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
user-agent external-format ssl)</font></strong></p>

<p>This function connects to the web server indicated by the <strong>uri</strong> and
sends the request.&nbsp;&nbsp; The arguments are the same as those for <strong>do-http-request</strong>
and are documented there.&nbsp;&nbsp; There is one additional argument: <strong>content-length</strong>.
&nbsp;&nbsp; This argument can be used to set the <strong>content-length </strong>header
value in the request.&nbsp; After setting the content-length the caller of <strong>make-http-client-request</strong>
would then be responsible for sending that many bytes of data to the socket to serve as
the body of the request.&nbsp;&nbsp; If <strong>content-length </strong>is given, then a
value for <strong>content</strong> should not be given.</p>

<p>If&nbsp; <strong>make-http-client-request</strong> succeeds in contacting the web
server and sending a request, a <strong>client-request </strong>object is returned.
&nbsp;&nbsp; If <strong>make-http-client-request</strong> fails, then an error is
signalled.</p>

<p>The returned <strong>client-request</strong> object contains an open socket to a web
server, thus you must ensure that client-request object isn't discarded before <strong>client-request-close</strong>
is called on it to close the socket and reclaim that resource.</p>

<p>After calling <strong>make-http-client-request </strong>the program will send the body
of the request (if any), and then it will call <strong>read-client-response-headers</strong>
to partially read the web server's response to the request.</p>

<p>The default value for <strong>external-format</strong> is the value of <strong>*default-aserve-external-format*</strong></p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p><a name="f-read-client-response"></a><strong><font face="Courier New">(read-client-response-headers
client-request)</font></strong></p>

<p>This function reads the response code and response headers from the web server.
&nbsp;&nbsp;&nbsp; After the function returns the program can use the <strong>client-request
</strong>accessors noted above to read the web server's response.&nbsp; The body of the
response (if any) has not been read at this point.&nbsp;&nbsp;&nbsp; You should use <strong>client-request-read-sequence</strong>
to read the body of the response</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p><a name="f-client-request-read-sequence"></a><strong><font face="Courier New">(client-request-read-sequence
buffer client-request<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&amp;key start end)</font></strong></p>

<p>This fills the <strong>buffer</strong> with the body of the response from the web
server.&nbsp;&nbsp; The buffer should either be a character array or an array of
(unsigned-byte 8).&nbsp;&nbsp;&nbsp; If given, <strong>start</strong> specifies the index
of the <em>first</em> element in the buffer in which to store, and <strong>end </strong>is
one plus the index of the <em>last</em> element in which to store.&nbsp; </p>

<p>The return value is one plus the last index in the buffer filled by this function. The
caller of the function must be prepared for having the buffer only partially filled.
&nbsp; If the return value is zero then it indicates an End of File condition.</p>

<p>&nbsp;</p>

<p><a name="f-client-request-read-close"></a><font face="Courier New"><strong>(client-request-close
client-request)</strong></font></p>

<p>The client-request object returned by make-http-request is closed.&nbsp;&nbsp; This
returns the resources used by this connection to the operating system.&nbsp; </p>

<p>&nbsp;</p>

<p><a name="f-uriencode-string"></a>(<strong><font face="Courier New">uriencode-string&nbsp;
string &amp;key external-format)</font></strong></p>

<p>Convert the string into a format that would be safe to use as a component of a url.
&nbsp;&nbsp;&nbsp; In this conversion most printing characters are not changed
&nbsp;&nbsp; All non printing characters and printing characters that could be confused
with characters that separate fields in a url are encoded a %xy where xy is the
hexadecimal representation of the char-code of the character.&nbsp;&nbsp; <br>
external-format defaults to the value of <strong>*default-aserve-external-format*</strong>.</p>

<hr>

<h2><a name="proxy"></a>Proxy</h2>

<p>AllegroServe can serve as an http proxy.&nbsp;&nbsp; What this means is that web
clients can ask AllegroServe to fetch a URL for them.&nbsp;&nbsp; The two primary uses for
a proxy server are 

<ol>
  <li>you have web clients on a local network and you would prefer that the web clients don't
    send messages out to the internet.&nbsp;&nbsp; You run AllegroServe on a machine that has
    access both to the internal network and to the internet.&nbsp; You then configure the web
    clients to proxy through AllegroServe (directions for doing this are given below).</li>
  <li>You wish to use AllegroServe's caching facility to store copies of pages locally to
    improve responsiveness.&nbsp; In this case you must start AllegroServe as a proxy server
    for the web clients who will use the cache.</li>
</ol>

<p>In order to run AllegroServe as a proxy server you should specify <strong>:proxy t</strong>
in the arguments to the <strong>net.aserve:start</strong> function.&nbsp;&nbsp; With this
specified AllegroServe will still act as a web server for pages on the machine on which
AllegroServe is running.&nbsp; AllegroServe will act as a proxy for requests to other
machines.</p>

<p>Each web browser has it's own way of specifying which proxy server it should use.
&nbsp; For Netscape version 4 select the <strong>Edit</strong> menu, then <strong>Preferences..</strong>.
and then click on the <strong>plus sign</strong> to the left of <strong>Advanced</strong>.
&nbsp; Then select <strong>Proxies</strong> and click on&nbsp; <strong>Manual Proxy
Configuration</strong> and the click on <strong>View</strong> and specify the name of the
machine running AllegroServe and the port number on which AllegroServe is listening.
&nbsp; Then click <strong>OK</strong> on all the dialog boxes.</p>

<p>For Internet Explorer 5 select the <strong>Tools</strong> menu, and then <strong>Internet
Options..</strong> and then the <strong>Connections</strong> tab, and then <strong>LAN
Settings</strong>.&nbsp;&nbsp; Click on <strong>Use a Proxy Server </strong>and then click
on <strong>Advanced</strong> and specify the machine name and port number for
AllegroServe.&nbsp; Then click on <strong>OK</strong> to dismiss the dialog windows.</p>

<p>&nbsp;</p>

<hr>

<h2><a name="cache"></a>Cache</h2>

<p>The AllegroServe cache is a facilty in development.&nbsp; We'll describe here the
current status of the code. </p>

<p>The cache consists of a memory cache and a set of zero or more disk caches.
&nbsp;&nbsp;&nbsp;&nbsp; Items initially live in the memory cache and are moved to the
disk caches when the memory cache fills up.&nbsp;&nbsp; Items enter the memory cache due
to a page being accessed via the proxy server.&nbsp;&nbsp; Items in the disk cache move
back to the memory cache if the data portion must be sent back to the requesting client
(some requests can be answered without sending back the contents of the page and for these
the item stays in the disk cache).</p>

<p>You specify the sizes of each cache.&nbsp;&nbsp; The disk caches will never grow beyond
the size you specified but the memory cache can exceed the specified size for a short
time.&nbsp; A background thread moves items from the memory cache to the disk caches and
we will allow you to control how often that thread wakes up and ensures that the memory
cache is within the desired constraints.</p>

<p>When <strong>net.aserve:start</strong> is called you specify if you want caching and if
so what size caches you want.&nbsp;&nbsp; A sample argument pair passed to <strong>net.aserve:start</strong>
is</p>

<pre>:cache '(:memory 10000000 :disk (&quot;/tmp/mycache&quot; 30000000) :disk (nil 20000000))</pre>

<p>This says that the memory cache should be 10,000,000 bytes and that there should be two
disk caches.&nbsp;&nbsp; One disk cache is the file &quot;/tmp/mycache&quot; and can grow
to 30,000,000 bytes and the other cache will have a name chosen by AllegroServe and it can
grow to 20,000,000 bytes.&nbsp;&nbsp; We should note here that one thing that
distinguishes the AllegroServe caching facilty from that found in many other http
proxy-caches is that AllegroServe uses a few&nbsp; large cache files rather than storing
each cached item in a separate file in the filesystem.&nbsp;&nbsp; </p>

<p>A few other ways of specifying caching at startup is:</p>

<pre>:cache t</pre>

<p>This will create a memory case of the default size (currently 10 megabytes) and it will
create no disk caches.</p>

<pre>:cache 20000000</pre>

<p>This will create a memory cache of 20,000,000 byte and no disk caches.</p>

<p>&nbsp;</p>

<p>When caching is enabled we publish two links to pages showing cache information.
&nbsp;&nbsp; This is useful during debugging and is likely to change in the future. &nbsp;
The two pages are&nbsp; <strong>/cache-stats</strong>&nbsp; and&nbsp; <strong>/cache-entries</strong>.</p>

<p>&nbsp;</p>

<hr>

<h2><a name="filters"></a>Request Filters</h2>

<p>After AllegroServe reads a request and before it checks the locators to find an entity
to handle the request, AllegroServe runs the request through a set of filters. </p>

<blockquote>
  <p>A filter is a function of one argument: the http-request object. The filter examines
  and possibily alters the request object. The idea is that filters can do large scale and
  simple url rewriting, such as changing all requests for one machine to another machine.
  The filtering occurs before the test to see if this is a proxy request so a filter can
  change a proxy request to a non proxy request or vice versa. </p>
  <p align="left">The currently active filters are found in two places.&nbsp; First the <strong>vhost-filters</strong>
  function of the applicable <strong>vhost</strong> returns a set of <strong>vhost</strong>
  specific filters.&nbsp;&nbsp; Next the <strong>wserver-filters</strong> function on the
  current <strong>wserver</strong> object returns a set of server global filters.
  &nbsp;&nbsp;&nbsp; Both of these functions are <strong>setf</strong>'able to change the
  set of filters.</p>
</blockquote>

<p>&nbsp;</p>

<p>A filter function returns <strong>:done</strong> if no more filters should be run after
this one. If the filter returns anything else then subsequent filters in the list are run
as well.&nbsp;&nbsp; If a filters in the <strong>vhost</strong> list returns <strong>:done</strong>
then the server global filters are not even checked.</p>

<p>When a filter function runs it's most likely going to be looking at two slots in the
request object, which are accessed via these functions: 

<ul>
  <li><strong>request-raw-uri </strong>- the actual uri given in the http command </li>
  <li><strong>request-uri</strong> - a constructed uri starting with the raw uri and adding
    information from the Host header field. This value is used to find the entity to run thus
    it has all the information about the request. </li>
</ul>

<p>Also the value of <font face="Courier New">(header-slot-value request :host)</font> is
important to check and possibly change. </p>

<p>If the browser is setup to access the internet directly then a request from the user
for <br>
&nbsp;&nbsp;&nbsp; <strong>http://foo.bar.com:23/whatever<br>
</strong><br>
will cause the request to be sent to the server at <strong>foo.bar.com </strong>port 23
and the request will have: 

<ol>
  <li>the request-raw-uri is <strong>/whatever </strong></li>
  <li>the request-uri is <strong>http://foo.bar.com:23/whatever </strong></li>
  <li>the Host header value is <strong>&quot;foo.bar.com:23&quot; </strong></li>
</ol>

<p><br>
<br>
<br>
If the browser is setup to send all requests through a proxy at <strong>proxy.blop.com</strong>
then a request for <br>
<strong>http://foo.bar.com:23/whatever </strong><br>
will come to <strong>proxy.blop.com</strong> and will have a different raw uri: 

<ol>
  <li>the request-raw-uri is now <strong>http://foo.bar.com:23/whatever </strong></li>
  <li>the request-uri is still <strong>http://foo.bar.com:23/whatever </strong></li>
  <li>the Host header value is still <strong>&quot;foo.bar.com:23&quot; </strong></li>
</ol>

<p>If the filter wants to alter the destination of request it should ensure that the three
values mentioned above are set appropriately for the destination. If the new destination
is not served by the current allegroserve wserver, then the filter will have to make sure
to turn it into a proxy request (and this will only work if this AllegroServe was started
with proxying enabled).</p>

<p>&nbsp;</p>

<hr>

<h2><a name="virtual_hosts"></a>Virtual Hosts</h2>

<p>It is possible for a single web sever to act like two or more indepenent web servers.
&nbsp; This is known as <em>virtual hosting</em>.&nbsp; AllegroServe supports the ability
to run any number of virtual hosts in a single instance of AllegroServe.</p>

<p>AllegroServe runs on a single machine and listens for requests on one port on one or
more more IP addresses.&nbsp;&nbsp; When a request arrives there is usually a header line
labelled <font face="Courier New">Host</font> whose value is the specific hostname typed
into the browser by the user.&nbsp;&nbsp; Thus if hostnames <font face="Courier New">www.foo.com</font>
and <font face="Courier New">www.bar.com </font>both point to the same machine then it's
possible for the webserver on that machine to distinguish a request for <font
face="Courier New">http://www.foo.com</font> from a request for <font face="Courier New">http://www.bar.com</font>
by looking at the <font face="Courier New">Host</font> header.</p>

<p>In order to make AllegroServe easy to use you can ignore the virtual hosting facility
until you plan to use it.&nbsp;&nbsp; As long as you don't specify a <strong>:host</strong>
argument to any of the publish functions when adding content to your site, everything you
publish will be visible from your web server no matter which hostname the web browser uses
to access your site.&nbsp; If you decide you want to make use of virtual hosting, then
read on.</p>

<h3>vhost class</h3>

<p>In AllegroServe a virtual host is denoted by a instance of class <strong>vhost</strong>.
&nbsp;&nbsp; The contents of a vhost object are:</p>

<table border="1" width="83%">
  <tr>
    <th width="26%">Accessor Function</th>
    <th width="57%">What</th>
    <th width="17%">initarg</th>
  </tr>
  <tr>
    <td width="26%">vhost-log-stream</td>
    <td width="57%">Stream to which to write logging information on requests to this virtual
    host</td>
    <td width="17%"><strong>:log-stream</strong></td>
  </tr>
  <tr>
    <td width="26%">vhost-error-stream</td>
    <td width="57%">Stream to which AllegroServe sends informational and error messages that
    are generated during request processing.</td>
    <td width="17%"><strong>:error-stream</strong></td>
  </tr>
  <tr>
    <td width="26%">vhost-names</td>
    <td width="57%">A list of all the names for this virtual host.&nbsp; </td>
    <td width="17%"><strong>:names</strong></td>
  </tr>
  <tr>
    <td width="26%">vhost-filters</td>
    <td width="57%">list of <a href="#filters">filter functions</a> </td>
    <td width="17%"><strong>:filters</strong></td>
  </tr>
</table>

<p>The defaults values for the two streams in a vhost object is the <strong>wserver-log-stream</strong>
from the server object.</p>

<p>Every instance of AllegroServe has a default vhost object that can be retrieved from
the <strong>wserver </strong>object via the function <strong>wserver-default-vhost.
&nbsp;&nbsp; </strong>If a request comes in for a virtual host that's not known, then it's
assumed to be for the default virtual host.</p>

<p>There are two ways to create virtual hosts in AllegroServe: implicitly or explicitly.
&nbsp;&nbsp; If a publish function is called with a <strong>:host</strong> value that
names a host not known to be a virtual host then a <strong>vhost</strong> instance will be
created automatically and stored in the <strong>wserver</strong>'s hash table that maps
names to <strong>vhost </strong>objects.&nbsp; This is implicit virtual host creation.</p>

<p>If you know ahead of time the virtual hosts you'll be serving then it's better to setup
all the virtual hosts explicitly.&nbsp;&nbsp; You create a <strong>vhost</strong> instance
with <strong>make-instance</strong> and you register each virtual host in the <strong>wserver-vhosts</strong>
table using <strong>gethash.</strong>&nbsp;&nbsp;&nbsp;&nbsp; Following is an example of
setting up a server to have two virtual hosts, one that responds to three names and one
that responds to two names.&nbsp;&nbsp; Since we are using the default vhost to represent
the first virtual host, this virtual host will also receive requests for names we haven't
mentioned explicitly.</p>

<p>&nbsp;</p>

<pre>(defun setup-virtual-hosts (server)
  (let ((vhost-table (wserver-vhosts server))
	(foo-names '(&quot;localhost&quot; &quot;www.foo.com&quot; &quot;foo.com&quot;))
	(bar-names '(&quot;www.bar.com&quot; &quot;store.bar.com&quot;)))
    
    (let ((default-vhost (wserver-default-vhost server)))
      (setf (vhost-names default-vhost) foo-names)
      (dolist (name foo-names)
	(setf (gethash name vhost-table) default-vhost)))
    
    (let ((bar-vhost (make-instance 'vhost :names bar-names)))
      (dolist (name bar-names)
	(setf (gethash name vhost-table) bar-vhost)))))

</pre>

<p>When a request comes in, AllegroServe will determine which vhost is the intended target
and if none is found it will select the default vhost as the intended target.&nbsp; The
vhost so determined will be stored in the<strong> http-request </strong>object in the slot
accessed by <strong>request-vhost</strong> function.</p>

<h3><a name="host_arg"></a>host argument to publish functions</h3>

<p>We now are in a position to describe what values the <strong>:host</strong> argument to
the publish functions can take on.&nbsp;&nbsp; The <strong>:host</strong> argument can be <strong>nil</strong>
or one of: 

<ol>
  <li>a string naming a virtual host.&nbsp; If there is no virtual host with this name a new
    virtual host object is created. </li>
  <li>a vhost object</li>
  <li>the symbol <strong>:wild</strong></li>
  <li>a list of items of the above items</li>
</ol>

<p>If the value of the <strong>:host </strong>argument is <strong>nil</strong>, then its
value is assumed to be <strong>:wild</strong>.</p>

<p>The value of the <strong>:host </strong>argument is converted into a list of one or
more vhost objects and/or the symbol <strong>:wild.</strong>&nbsp;&nbsp;&nbsp; The meaning
of a vhost is clear: it means that this entity will be visible on this virtual host.
&nbsp; The meaning of <strong>:wild </strong>is that this entity will be visible on <em>all</em>
virtual hosts, except it can be shadowed by a entity specified for a particular virtual
host.&nbsp; Thus you could publish an entity for<strong> :path &quot;/&quot; </strong>and <strong>:host
:wild</strong> and it will be used for all virtual hosts that don't specify a entity for <strong>:path
&quot;/&quot;</strong>.&nbsp; Note that when a request comes in and the search is done for
an entity to match the request every step of the way we look first for a vhost specific
handler and then a <strong>:wild</strong> handler&nbsp;&nbsp; It is <em>not</em> the case
that we first do a complete search for a vhost specific handler and then restart the
search this time looking for a <strong>:wild</strong> handler.</p>

<p>&nbsp;</p>

<hr>

<h2><a name="timeouts"></a>Timeouts</h2>

<p>A web server is a program that provides resources to client program connecting over the
network.&nbsp; The resources a web server has to offer is limited and it's important that
network problems or buggy clients don't cause those resources to be unavailable to new
clients.&nbsp;&nbsp; AllegroServe uses timeouts to ensure that no client can hold a web
server resource for more than a certain amount of time.</p>

<p>Three common ways for a resource to be held are 

<ol>
  <li>A client stops sending a request in the middle of the request.&nbsp;&nbsp; This can
    happen if the client machine crashes or&nbsp; if the client's machine loses network
    connectivity with the&nbsp; machine running AllegroServe.</li>
  <li>A client stops reading the response to its request.&nbsp;&nbsp;&nbsp; The networking
    code will automatically stop the sender from writing new data if the receiver has a lot of
    existing data to read. </li>
  <li>The response function to an http request can take a very long time, or may even be in an
    infinite loop.&nbsp;&nbsp; This could be due to a bug in a http response function or
    something unexpected, like a database query taking a long time to finish.</li>
</ol>

<p>&nbsp;</p>

<h3>Acl 6.0 or older</h3>

<p>For AllegroServe running in Acl 6.0 or <em>older</em> timeouts are done this way:</p>

<p><strong>net.aserve::*read-request-timeout*</strong>&nbsp; - number of seconds
AllegroServe allows for the request line (the first line) and all following header lines.
&nbsp; The default is 20 seconds.</p>

<p><strong>net.aserve::*read-request-body-timeout* </strong>- number of seconds
AllegroServe allows for the body of the request (if any) to be read.&nbsp;&nbsp; The
default is 60 seconds.</p>

<p><strong>(wserver-response-timeout wserver)</strong> - the number of seconds
AllegroServe allows for an http request&nbsp; function to be run and finished sending back
its response.&nbsp; The initial value for this slot of the wserver object is found in <strong>*http-response-timeout*
</strong>which defaults to 120 seconds.&nbsp; You can alter this timeout value with the <strong>:timeout</strong>
argument to <strong>with-http-response</strong> or by specifying a <strong>:timeout</strong>
when publishing the entity.</p>

<h3>Acl 6.1 or newer</h3>

<p>In Acl 6.1 we added the capability of having each I/O operation to a socket stream time
out.&nbsp;&nbsp; This means that we don't have to predict how long it should take to get a
request or send a response.&nbsp; As long as we're making progress reading or writing we
know that the client on the other end of the network connection is alive and well.
&nbsp;&nbsp; We still need a timeout to handle case (3) above but we can allow a lot more
time for the http response since we aren't using this timer to catch dead clients as well.
&nbsp;&nbsp; Thus we have these timeout values:</p>

<p><a name="f-wserver-io-timeout"></a><strong>(wserver-io-timeout wserver)</strong> - the
number of seconds that AllegroServe will wait for any read or write operation to the
socket to finish.&nbsp;&nbsp; The value is initialized to the value of *http-io-timeout*
&nbsp; which defaults to 60 seconds.</p>

<p><a name="f-wserver-response-timeout"></a><strong>(wserver-response-timeout wserver)</strong>
-&nbsp; the number of seconds AllegroServe allows for an http request function to be run
and finished sending back its response. The initial value for this slot of the wserver
object is found in <strong>*http-response-timeout*</strong> which defaults to 300 seconds.
You can alter this timeout value with the :timeout argument to <strong>with-http-response</strong>
or by specifying a <strong>:timeout </strong>argument to the publish function creating the
entity.</p>

<p><strong>publish-directory </strong>and <strong>publish-file </strong>default their <strong>timeout</strong>
argument in a way that makes sense based on whether the Lisp supports I/O timeouts.
&nbsp;&nbsp; If I/O timeouts are supported then there is no reason to do a global timeout
for the whole response if you're just sending back a file.&nbsp;&nbsp; Thus in this case
the <strong>timeout</strong> argument defaults to a huge number.</p>

<p>&nbsp;</p>

<hr>

<h2><a name="miscellaneous"></a>Miscellaneous</h2>

<p><a name="f-ensure-stream-lock"></a><strong><font face="Courier New">(ensure-stream-lock
stream)</font></strong></p>

<p>The function adds a <a
href="http://www.franz.com/support/documentation/6.1/doc/multiprocessing.htm#process-locks-1">process
lock</a> to <strong>stream</strong>'s property list (under the indicator<strong> :lock</strong>)
if no such lock is present.&nbsp;&nbsp; Then it returns the object <strong>stream</strong>.</p>

<p>The AllegroServe logging functions make use of the stream's lock to ensure that only
one thread at a time write log information to the stream.&nbsp;&nbsp; If the logging
functions find that a a log stream doesn't have a lock associated with it then the log
information will still be written to the stream but under heavy load the log information
from multiple threads will become intermixed. </p>

<p>&nbsp;</p>

<p><a name="f-map-entities"></a><font face="Courier New"><strong>(map-entities function
locator)</strong></font></p>

<p>When<strong> </strong>one of the<strong> </strong>publish functions is called enties
are placed in <em>locator<strong> </strong></em>objects.&nbsp;&nbsp; The locator objects
are then checked when http requests come in to find the appropriate entity.&nbsp; <strong>map-entities</strong>
will apply the given <strong>function</strong> of one argument to all the entities in the
given<strong> locator</strong>.&nbsp;&nbsp; One common use of <strong>map-entities</strong>
is to find entities that you no longer wish to be published.&nbsp; For that reason <strong>map-entities</strong>
will remove the entity the passed to the <strong>function</strong> if the <strong>function</strong>
returns the keyword symbol <strong>:remove</strong> as its value.</p>

<p>&nbsp;</p>

<hr>

<h2><a name="asaservice"></a>Running AllegroServe as a Service on Windows NT</h2>

<p>On Windows NT (and Windows 2000 and Windows XP) when you log off all the programs you
are running are terminated.&nbsp;&nbsp; If you want to run AllegroServe on your machine
after you log out you have to start it as a <strong>Windows Service.&nbsp; </strong>This
is easy to do thanks to code contributed by Ahmon Dancy.&nbsp;&nbsp; </p>

<p>The first step is to download the <a href="http://opensource.franz.com/ntservice">ntservice
code and documentation</a> from the Franz <a href="http://opensource.franz.com">opensource
site</a>.&nbsp; Read the documentation carefully especially as regards the different
capabilities of the accounts under which you may choose to run AllegroServe.&nbsp;&nbsp; </p>

<p>You'll probably want to build an AllegroServe application that can run either normally
or as a service,.&nbsp; You can run it normally to debug it and then start it as a service
when you're satisifed that it works.</p>

<p>Following is an example of how this can be done.&nbsp;&nbsp; I've decided that if the <font
face="Courier New">/service</font> argument is given on the command line when I start my
application then I'll start my application as a service, otherwise I start it normally.
&nbsp;&nbsp;&nbsp;&nbsp; Here is the <strong>restart-init-function</strong> (to <strong>generate-application</strong>)
that I define:</p>

<pre>(defun start-aserve-application ()
  (flet ((start-application ()
	   (net.aserve:start :port 8020)
	   (loop (sleep 100000))))
    (if* (member &quot;/service&quot; (sys:command-line-arguments) :test #'equalp)
     then ; start as  a service
	  (ntservice:start-service #'start-application)
     else ; start as a normal app
	  (start-application)))))</pre>

<p>&nbsp;</p>

<p>I use <font face="Courier New">(loop (sleep 100000))</font> to ensure that the <strong>restart-init-function</strong>
never returns.</p>

<p>&nbsp;</p>

<p>In order to register my application as a service to the operating system I call <strong>ntservice:create-service</strong>
like this:</p>

<pre>(ntservice:create-service &quot;aservetest&quot; &quot;Aserve Test Service&quot;
     &quot;c:\\acl61\\testservice\\testapp\\testapp.exe -- /service&quot;)</pre>

<p>Note that I use &quot;<font face="Courier New">--</font>&quot; before the &quot;<font
face="Courier New">/service</font>&quot;.&nbsp; This is <em>very </em>important.
&nbsp;&nbsp; The &quot;<font face="Courier New">--</font>&quot; separates the arguments
used to start up the program from the arguments passed to the program itself. &nbsp;&nbsp;
The call to <strong>ntservice:create-service</strong> is done only once and need not be
done from within your application.&nbsp; </p>

<p>Once an application is registered as a service you can start it by going to the Control
Panel, selecting Administrative Tools and then Services.&nbsp;&nbsp; Locate the service
you just added, right click on it and select <strong>start</strong>.&nbsp;&nbsp; You can
stop the service with a a right click as well. </p>

<p>&nbsp;</p>

<hr>

<h2><a name="international-chars-aserve"></a>Using International Characters in
AllegroServe</h2>

<p>A <em>character set</em> is a collection of characters and a rule to encode them as a
sequence of octets.&nbsp;&nbsp; The default character set for web protocols is Latin1
(also known as ISO 8859-1).&nbsp;&nbsp; The Latin1 character set represents nearly every
character and punctuation needed for western European languages (which includes English).
&nbsp;&nbsp; </p>

<p>If you want to work with characters outside the Latin1 set you'll want to use the <a
href="http://www.franz.com/support/documentation/6.1/doc/iacl.htm">International version
of Allegro CL</a> which represents characters internally by their 16-bit <a
href="http://www.unicode.org">Unicode</a> value.&nbsp;&nbsp;&nbsp; In this section we'll
assume that you're using International Allegro CL.</p>

<p>What the web protocols refer to as <strong>charset</strong> (character set) Allegro CL
refers to as an <strong>external-format</strong>.&nbsp; Allegro CL uses a different term
since it always uses 16-bit Unicode to represent characters internally.&nbsp; 16 bit
unicode can represent nearly all characters on the planet.&nbsp; It's only when those
characters are read from or written to devices outside of Lisp that the actual encoding of
those characters into octets matters.&nbsp;&nbsp;&nbsp; Thus the <strong>external-format</strong>
specifies how characters are encoded and specifies which Unicode characters are part of
the character set that the external-format defines.&nbsp; Attempts to write a Unicode
character that's not part of the character set results in a question mark being written.</p>

<p>External-formats are also used in Allegro CL to do certain character to character
transformations.&nbsp; In particular on the Windows platform external formats are used to
convert the lisp end of line (a single #\newline character) to the #\return #\linefeed
character that is standard on Windows.&nbsp;&nbsp; Thus an external format such as <strong>:utf-8</strong>
&nbsp; has a different effect on Windows than on Unix, and this is not desireable for web
applications.&nbsp;&nbsp; The function call <font face="Courier New">(crlf-base-ef&nbsp;:utf-8)</font>
returns an external format on Windows and on Unix that simply does the character encoding
part of the external format, and thus this is the external format you would want to use in
a web application.</p>

<h3>server to client (browser) character transfer</h3>

<p>When a web server returns a response to a client it sends back a response line, a
header and optionally a body.&nbsp;&nbsp; The response line and header are always sent
using a subset of the Latin1 character set (the subset corresponding the the US ASCII
character set).&nbsp;&nbsp; The body is sent using the full Latin1 character set, unless
otherwise specified.&nbsp; To specify the character set of the body you add an extra
parameter to the Content-Type header.&nbsp;&nbsp; Instead of specifying a content type of
&quot;text/html&quot; you might specify &quot;text/html;&nbsp;charset=iso-8859-2&quot;.
&nbsp;&nbsp; This alerts the http client that it must interpret the octets comprising the
body of the response according to the iso-8859-2 character set.&nbsp;&nbsp; This however
is <em>not<strong> </strong></em>enough to make AllegroServe encode the Unicode characters
it's sending to the client using the approrpriate external format.&nbsp; You would have to
do this:</p>

<pre>(with-http-response (req ent)
  (with-http-body (req ent :external-format (crlf-base-ef :iso8859-2))
     ... generate and write page here..
))</pre>

<p>Note that the charset names and external format name are similar but not identical.
&nbsp; Check <a href="http://www.iana.org/assignments/character-sets">here</a> for the
charset names and check <a
href="http://www.franz.com/support/documentation/6.1/doc/iacl.htm#external-formats-1">here</a>
for the Allegro CL external format names.</p>

<p>In order to make it easier to specify external formats in AllegroServe you can specify
a default external format when you start the server (with the <strong>:external-format</strong>
argument to the <strong>start</strong> function).&nbsp;&nbsp; The variable <strong>*default-aserve-external-format*
</strong>will then be bound to this external format in each of the threads that processes
http requests.&nbsp;&nbsp; It's the value of <strong>*default-aserve-external-format*</strong>
that is used as the default argument to the :external-format argument to <strong>with-http-body</strong>.</p>

<p>The default value of the <strong>:external-forma</strong>t argument to the <strong>start</strong>
function, and thus the default value of *<strong>default-aserve-external-format*</strong>,
is <strong>(crlf-base-ef :latin1-base</strong>).&nbsp;&nbsp; This means that regardless of
the locale in which you run AllegroServe, AllegroServe will by default using the Latin1
character set, which is what is expected by web clients..</p>

<p>A very useful character set is <strong>utf-8</strong> which is the whole Unicode
character set and thus comprises all of the characters you can store inside Lisp.
&nbsp;&nbsp; The corresponding Allegro CL external format is the value of <font
face="Courier New"><strong>(crlf-base-ef :utf-8)</strong></font>.&nbsp;&nbsp; Specifying
this character set allows you to write web pages that can characters from nearly every
language in the world (whether the web browser can find the glyphs to display all those
characters is another matter). </p>

<h3>client (browser) to server character transfer</h3>

<p>The brower sends characters to the web server when the user enters data into a form and
submits the form.&nbsp;&nbsp; The important thing to remember is that the browser will
encode characters using the character set that was specified for the web page containing
the form.&nbsp; If you fail to specify a <strong>charset</strong> when the page was given
to the web browser then the web browser will decide on its own how to encode characters
that aren't part of the default character set ( which is of course Latin1). &nbsp;&nbsp;
The browser will <em>not</em> tell you which encoding it chose. &nbsp; Therefore if you
ever plan on allowing&nbsp; non-Latin1 characters to be specified in your forms you'll
want to specify a <strong>charset</strong> for the page containing the form. </p>

<p>You can specify the charset in the Content-Type field of the header that's sent with
the page (as we described above) or you can put it in the page itself using a meta tag:</p>

<pre>&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;</pre>

<p>Retrieving form data in AllegroServe is done with the <strong>request-query</strong>
function and that function takes an <strong>:external-format</strong> argument so you can
specify how the form data can be decoded.&nbsp;&nbsp; If your form sends multipart data
then you can use the <strong>:external-format</strong> argument to <strong>get-multipart-sequence</strong>
to retrieve the form data and decode the data.</p>

<h3>examples</h3>

<p>The AllegroServe test page has links to a few pages that show how international
characters work with AllegroServe.&nbsp; One of these is the the International Character
Display page.&nbsp; This page&nbsp; shows what happens when the <strong>charset</strong>
and <strong>external-format</strong> are set to different values and a page containing
international characters is displayed.&nbsp; It demonstrates how it important is is that
those two character set specifications be kept in sync, and it shows that <strong>utf-8</strong>
is most likely the best choice for a character set for your web pages.</p>

<p>&nbsp;</p>

<hr>

<h2><a name="debugging"></a>Debugging</h2>

<p>Debugging entity handler functions is difficult since these are usually run on a
separate lisp thread.&nbsp; Also AllegroServe catches errors in entity handler functions,
thus preventing you from interactively diagnosing the problem.</p>

<p>You can put AllegroServe in a mode that makes debugging easier with the <font
face="Courier New">net.aserve::debug-on</font> function.&nbsp;&nbsp; Note that this is not
an exported function to emphasize the fact that you are working with the internals of
AllegroServe.</p>

<p>&nbsp;</p>

<p><a name="f-debug-on"></a><strong><font face="Courier New">(net.aserve::debug-on
&amp;rest debugging-features-to-enable)</font></strong></p>

<p>We've classified the debugging features and given each a keyword symbol name.
&nbsp;&nbsp; This function turns on those named features.&nbsp; If no arguments are given,
then <strong>debug-on</strong> prints the list of debugging features and whether each is
enabled.</p>

<p>&nbsp;</p>

<p><a name="f-debug-off"></a><strong><font face="Courier New">(net.aserve::debug-off
&amp;rest debugging-features-to-disable)</font></strong></p>

<p>This function turns off the given list of features.</p>

<p>&nbsp;</p>

<p>The list of debug features are:</p>

<table border="1" width="100%">
  <tr>
    <td width="18%"><strong>:info</strong></td>
    <td width="82%">AllegroServe prints information at certain places while doing its
    processing. &nbsp; </td>
  </tr>
  <tr>
    <td width="18%"><strong>:xmit</strong></td>
    <td width="82%">AllegroServe prints what it receives from and sends to the client.&nbsp;
    In some cases the body of a request or response will not be printed.</td>
  </tr>
  <tr>
    <td width="18%"><strong>:notrap</strong></td>
    <td width="82%">When enabled, this prevents AllegroServe from catching errors in entity
    handler functions.&nbsp; If an error occurs and you're running in an evironment where
    background processes automatically create new windows (such as the emacs-lisp interface)
    then you'll be given a chance to :zoom the stack and diagnose the problem.&nbsp; Note that
    if a timeout has been established to limit the amount of time that a certain step is
    allowed (and this is done by default) then the interactive debugging session will be
    aborted when the timeout is reached.</td>
  </tr>
</table>

<p>&nbsp;</p>

<p>Two pseudo debug features are <strong>:all</strong> and <strong>:log.</strong>. &nbsp;
Specifying <strong>:all </strong>to <strong>debug-on</strong> or <strong>debug-off</strong>
&nbsp; is the same as listing all of the debug features.&nbsp;&nbsp; Specifying <strong>:log</strong>
is the same as specifying all features except <strong>:notrap.</strong></p>

<p>&nbsp;</p>
</body>
</html>
