;;; Copyright (c) 2005-2006, Rudi Schlatte. All rights reserved.

;;; Redistribution and use in source and binary forms, with or without
;;; modification, are permitted provided that the following conditions
;;; are met:

;;;   * Redistributions of source code must retain the above copyright
;;;     notice, this list of conditions and the following disclaimer.

;;;   * Redistributions in binary form must reproduce the above
;;;     copyright notice, this list of conditions and the following
;;;     disclaimer in the documentation and/or other materials
;;;     provided with the distribution.

;;; THIS SOFTWARE IS PROVIDED BY THE AUTHOR 'AS IS' AND ANY EXPRESSED
;;; OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
;;; WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;;; ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
;;; DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
;;; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
;;; GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;;; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
;;; WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
;;; NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
;;; SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

;;; WRITTEN BY: Rudi Schlatte rudi@constantly.at

(in-package :cl-muproc.compat)

;;; DEBUGGING

(defmacro %with-debugging-stack% (&body body)
  "This macro sets up a debuggable stack, enabling stack dumps
in error and signal handlers - default no-op implementation"
  `(progn ,@body))

;;; SCHEDULING

(defmacro %with-exclusive-access% (&body body)
  `(ccl:with-lock-grabbed (*giant-lock*) ,@body))

(defmacro %with-lock% ((lock) &body body)
  `(ccl:with-lock-grabbed (,lock) ,@body))

(declaim (inline %make-lock%))
(defun %make-lock% (&key name)
  (ccl:make-lock name))

;;; SPECIALS

(defvar *giant-lock* (%make-lock%))

;;; QUEUES

(defstruct (queue (:constructor %make-queue%)
                  (:copier nil)
                  (:predicate nil))
  (semaphore (ccl:make-semaphore))
  (lock (ccl:make-lock))
  data)

(declaim (inline %enqueue%))
(defun %enqueue% (queue packet)
  (progn
    (ccl:with-lock-grabbed ((queue-lock queue) "enqueueing")
      (setf (queue-data queue) (nconc (queue-data queue) (list packet))))
    (ccl:signal-semaphore (queue-semaphore queue))))

(declaim (inline %dequeue%))
(defun %dequeue% (queue)
  (progn
     (ccl:wait-on-semaphore (queue-semaphore queue))
     (ccl:with-lock-grabbed ((queue-lock queue) "dequeueing")
       (assert (queue-data queue))
       (pop (queue-data queue)))))

(declaim (inline %queue-empty-p%))
(defun %queue-empty-p% (queue)
  (ccl:with-lock-grabbed ((queue-lock queue) "checking")
    (null (queue-data queue))))

;;; PROCESSES

(defclass muproc-process (ccl:process)
  ((plist :initform nil :accessor %process-plist%)))

(defun %all-processes% ()
  (ccl:all-processes))

(defun %current-process% ()
  "Returns a reference to the currently running muproc.  The reference
is identical to that of the underlying LISP process."
  ccl:*current-process*)

(defun %process-alive-p% (muproc)
  (ccl::process-active-p muproc))

(defun %process-interrupt% (muproc fn &rest args)
  (apply #'ccl:process-interrupt muproc fn args))

(defun %process-p% (obj)
  ;; HACK: we don't tell muproc about threads generated by other means
  ;; (cf. `muproc-p' in muproc.lisp)
  (typep obj 'muproc-process))

(defun %process-priority% (muproc)
  (ccl:process-priority muproc))

(defun %process-run-function% (name fn &rest args)
  (let ((process (ccl:make-process name :class 'muproc-process)))
    (apply #'ccl:process-preset process fn args)
    (ccl:process-enable process)))

;;; TIMERS

(defclass timer (ccl:process)
  ((fn :accessor timer-function)
   (args :accessor timer-function-args)))

(defun %make-timer% (fn muproc)
  (let  ((timer (ccl:make-process "a timer" :class 'timer)))
    (setf (timer-function timer) fn)
    (setf (timer-function-args timer)
          (list muproc))
    timer))

(defun do-after (timer time)
  (ccl:process-preset
   timer
   (lambda ()
     (let ((sem (ccl:make-semaphore)))
       (ccl:timed-wait-on-semaphore sem time))
     (apply (timer-function timer) (timer-function-args timer))))
  (ccl:process-enable timer))

(defun do-every (timer time interval)
  (ccl:process-preset
   timer
   (lambda ()
     (let ((sem (ccl:make-semaphore))
           (next-time time))
       (loop
          (ccl:timed-wait-on-semaphore sem next-time)
          (apply (timer-function timer) (timer-function-args timer))
          (setf next-time interval)))))
  (ccl:process-enable timer))

(defun %schedule-timer-relative% (timer relative-expiry-time
                                  &optional repeat-period)
  (if repeat-period
      (do-every timer relative-expiry-time repeat-period)
      (do-after timer relative-expiry-time)))

(defun %unschedule-timer% (timer)
  (ccl:process-kill timer))

(defun invoke-with-timeout (seconds bodyfn timeoutfn)
  (block timeout
    (let* ((process ccl:*current-process*)
           (timer (ccl:process-run-function
                   "with-timeout-timer"
                   #'(lambda () 
                       (sleep seconds)
                       (ccl:process-interrupt process
                                              #'(lambda ()
                                                  (return-from timeout
                                                    (funcall timeoutfn))))))))
      (unwind-protect (funcall bodyfn)
        (ccl:process-kill timer)))))


(defmacro %with-timeout% ((seconds &body timeout-forms) &body body)
  "Execute BODY; if execution takes more than SECONDS seconds, terminate
and evaluate TIMEOUT-FORMS."
  `(invoke-with-timeout ,seconds #'(lambda () ,@body)
                        #'(lambda () ,@timeout-forms)))

