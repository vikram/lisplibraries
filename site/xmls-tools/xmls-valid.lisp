;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; xmls-valid.lisp: Utilities for validating XML against rules
;;;; Copyright (C) 2004, 2006 Robert Marlow <bobstopper@bobturf.org>
;;;;
;;;; This library is free software; you can redistribute it and/or
;;;; modify it under the terms of the GNU Library General Public
;;;; License as published by the Free Software Foundation; either
;;;; version 2 of the License, or (at your option) any later version.
;;;;
;;;; This library is distributed in the hope that it will be useful,
;;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;;;; Library General Public License for more details.
;;;;
;;;; You should have received a copy of the GNU Library General Public
;;;; License along with this library; if not, write to the
;;;; Free Software Foundation, Inc., 59 Temple Place - Suite 330,
;;;; Boston, MA  02111-1307, USA.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(in-package :xmls-tools)


(defun validate-xml (xml rules)
  "Accepts an XML tree as generated by xmls and checks it against RULES
to determine if the XML is valid for that DTD. Returns two values: T or
NIL depending on whether the XML passes as valid, and an error message
string in the case of the XML being invalid."
  (multiple-value-bind (valid-p error-msg)
      (catch 'invalid-xml
	(validate-tree xml rules))

    (if valid-p
	(values t nil)
      (values valid-p error-msg))))


;;; XML is a tree structure. We process the tree in depth-first order.
;;; Validate-tree represents this order by first validating that all direct
;;; children of the parent node belong and all attributes of the parent
;;; node belong and then calling validate-children to continue on with
;;; the parents. validate-tree's job is to validate the parent.
;;; validate-children's job is to then call validate-tree on each child in
;;; turn.

(defun validate-tree (xml rules)
  "Does the actual validation work as defined by validate-xml. Use
validate-xml"
  (typecase xml

    ;; XML string is empty. Always return true.
    (null (values t nil))
    
    ;; This XML just contains character data. We don't care about that.
    (string (values t nil))
    
    ;; This XML includes a subtree. This is the interesting bit.
    (cons
     (validate-children-against-rules (extract-xml-content-elements
				       (nthcdr 2 xml))
				      (third (assoc (car xml) rules
						    :test #'equal)))
     (validate-attributes-against-rules (second xml)
					(second (assoc (car xml) rules
						       :test #'equal)))
     (validate-children (nthcdr 2 xml) rules))))


(defun validate-children (children rules)
  "Validates each subtree given in CHILDREN against RULES"
  (if (null children)
      (values t nil)
    (progn
      (validate-tree (car children) rules)
      (validate-children (cdr children) rules))))


(defun validate-children-against-rules (child-summary-list rules)
  "Checks that all subtree elements in CHILD-SUMMARY-LIST exist as
being permissible in RULES - a subset of the global RULES DTD which
defines what children are permissible for this child list's parent
element. Also ensures that all elements occur the correct number of
times as defined by RULES."
  (let ((remaining-children (copy-list child-summary-list)))
    (dolist (rule rules)
      (let* ((child-name (car rule))
	     (frequency-permitted (cdr rule))
	     (child (assoc child-name remaining-children
			   :test #'equal))
	     (child-frequency (or (cdr child) 0)))
	(case frequency-permitted
	  ((:nil-or-one)
	   (unless (or (= child-frequency 0)
		       (= child-frequency 1))
	     (throw 'invalid-xml
		    (values nil (format nil "zero or one ~A elements required"
					child-name)))))
	
	  ((:one-or-more)
	   (unless (> child-frequency 0)
	     (throw 'invalid-xml
		    (values nil (format nil "one or more ~A elements required"
					child-name)))))
	
	  ((:one)
	   (unless (= child-frequency 1)
	     (throw 'invalid-xml
		    (values nil (format nil "exactly one ~A elements required"
					child-name)))))
	
	  ((:any)
	   (unless (> child-frequency -1)
	     (throw 'invalid-xml
		    (values nil
			    (format nil
				    "Something very strange happened - negative ~A elements"
				    child-name))))))

	(setq remaining-children (delete child remaining-children))))
    
    (when (not (null remaining-children))
      (if (eql (caar remaining-children) :pcdata)
	  (throw 'invalid-xml
		 (values nil "Invalid PCDATA present"))
	  (throw 'invalid-xml
	     (values nil "Invalid elements present"))))

    (values t nil)))


(defun extract-xml-content-elements (child-list)
  "Takes CHILD-LIST, a list of objects existing as children for a parent tree,
and returns a list of the names of any elements and :PCDATA for any character
data."
  (let ((content-list nil))
    (dolist (child child-list)
      (typecase child
	(cons
	 (let ((content-match (assoc (first object) content-list
				     :test #'equal)))
	   (if content-match
	       (setf (cdr content-match) (1+ (cdr content-match)))
	       (setf content-list (acons (car object) 1 content-list)))))
	
	(string
	 (if (and (> (length object) 0)
		  (not (assoc :pcdata content-list)))
	     (setq content-list (acons :pcdata nil content-list))))
	
	(t (throw 'invalid-xml
		  (values nil "Encountered invalid content type")))))
    content-list))


(defun validate-attributes-against-rules (attribs rules)
  "Takes a list of XML attributes in ATTRIBS and checks against rules to
ensure they all belong, have the correct form and no required attributes
are missing"
  (let ((remaining-attributes (copy-list attribs)))
    (dolist (rule rules)
      (let* ((attrib-name (first rule))
	     (type-permitted (second rule))
	     (defaults (third rule))
	     (attrib (assoc attrib-name remaining-attributes
			    :test #'equal))
	     (attrib-value (cadr attrib)))
	
	(case defaults

	  ((:required)
	   (unless attrib
	     (throw 'invalid-xml
		    (values nil
			    (format nil "Required Attribute ~A missing"
				    attrib-name)))))

	  ((:implied) t)

	  ((:fixed)
	   (unless (equal attrib-value (fourth rule))
	     (throw 'invalid-xml
		    (values nil
			    (format nil "Attribute required to be ~A"
				    (fourth rule))))))

	  ((:default)
	   (unless attrib
	     (setf attrib-value (fourth rule))))

	  (t (throw 'invalid-xml
		    (values nil "Unexpected attribute default specification"))))

	(case type-permitted

	  ((:cdata) t)

	  ((:id) t) ; Not tested

	  (t
	   (if (listp type-permitted)
	       (unless (member attrib-value type-permitted :test #'equal)
		 (throw 'invalid-xml
			(values nil (format nil "Attribute must be one of ~A"
					    type-permitted)))))))

	(setq remaining-attributes (delete attrib remaining-attributes))))
    
    (if (null remaining-attributes)
	(values t nil)
      (throw 'invalid-xml
	     (values nil (format nil "Unexpected attributes present: ~{~A ~}"
				 (mapcar #'car remaining-attributes)))))))

