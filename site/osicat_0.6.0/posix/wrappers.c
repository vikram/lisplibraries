/*
 * This file has been automatically generated by cffi-grovel.
 * Do not edit it by hand.
 */

#if defined(__linux__)
#define _XOPEN_SOURCE 600
#define _LARGEFILE_SOURCE
#define _LARGEFILE64_SOURCE
#define _FILE_OFFSET_BITS 64
#endif
#include <string.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <dirent.h>
#include <sys/time.h>
#include <syslog.h>
#include <sys/mman.h>
#include <sys/resource.h>
#include <sys/statvfs.h>
off_t lseek_cffi_wrap(int fildes, off_t offset, int whence)
{
  return lseek(fildes, offset, whence);
}

int truncate_cffi_wrap(const char* path, off_t length)
{
  return truncate(path, length);
}

int ftruncate_cffi_wrap(int fd, off_t length)
{
  return ftruncate(fd, length);
}

void* mmap_cffi_wrap(void* start, size_t length, int prot, int flags, int fd, off_t offset)
{
  return mmap(start, length, prot, flags, fd, offset);
}

int stat_cffi_wrap(const char* file_name, struct stat* buf)
{
  return stat(file_name, buf);
}

int fstat_cffi_wrap(int filedes, struct stat* buf)
{
  return fstat(filedes, buf);
}

int lstat_cffi_wrap(const char* file_name, struct stat* buf)
{
  return lstat(file_name, buf);
}

ssize_t pread_cffi_wrap(int fd, void* buf, size_t count, off_t offset)
{
  return pread(fd, buf, count, offset);
}

ssize_t pwrite_cffi_wrap(int fd, const void* buf, size_t count, off_t offset)
{
  return pwrite(fd, buf, count, offset);
}

int readdir_r_cffi_wrap(DIR* dirp, struct dirent* entry, struct dirent** result)
{
  return readdir_r(dirp, entry, result);
}

int getrlimit_cffi_wrap(int resource, struct rlimit* rlim)
{
  return getrlimit(resource, rlim);
}

int setrlimit_cffi_wrap(int resource, const struct rlimit* rlim)
{
  return setrlimit(resource, rlim);
}

int statvfs_cffi_wrap(const char* path, struct statvfs* buf)
{
  return statvfs(path, buf);
}

int fstatvfs_cffi_wrap(int fd, struct statvfs* buf)
{
  return fstatvfs(fd, buf);
}

int fcntl_without_arg_cffi_wrap(int fd, int cmd)
{
  return fcntl(fd, cmd);
}

int fcntl_with_int_arg_cffi_wrap(int fd, int cmd, int arg)
{
  return fcntl(fd, cmd, arg);
}

int fcntl_with_pointer_arg_cffi_wrap(int fd, int cmd, void* arg)
{
  return fcntl(fd, cmd, arg);
}

int get_errno_cffi_wrap()
{
  return errno;
}

int set_errno_cffi_wrap(int value)
{
  errno = value;
  return errno;
}

int strerror_r_cffi_wrap(int errnum, char* buf, size_t buflen)
{
  return strerror_r(errnum, buf, buflen);
}

int log_mask_cffi_wrap(int priority)
{
  return LOG_MASK(priority);
}

int log_upto_cffi_wrap(int priority)
{
  return LOG_UPTO(priority);
}

int mknod_cffi_wrap(const char* path, mode_t mode, dev_t dev)
{
  return mknod(path, mode, dev);
}

int dirfd_cffi_wrap(DIR* dir)
{
  return dirfd(dir);
}

int s_isreg_cffi_wrap(mode_t mode)
{
  return S_ISREG(mode);
}

int s_isdir_cffi_wrap(mode_t mode)
{
  return S_ISDIR(mode);
}

int s_ischr_cffi_wrap(mode_t mode)
{
  return S_ISCHR(mode);
}

int s_isblk_cffi_wrap(mode_t mode)
{
  return S_ISBLK(mode);
}

int s_isfifo_cffi_wrap(mode_t mode)
{
  return S_ISFIFO(mode);
}

int s_islnk_cffi_wrap(mode_t mode)
{
  return S_ISLNK(mode);
}

int s_issock_cffi_wrap(mode_t mode)
{
  return S_ISSOCK(mode);
}

